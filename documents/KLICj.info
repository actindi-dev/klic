Info file: KLICj.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `klicj.tex'
using `texinfmt.el' version 2.32 of 19 November 1993.


このファイルは KLIC に関するドキュメントです。KLIC は KL1を移植実装する
ものです。このマニュアルは、 KLIC 3.002 版に相当します。

Copyright 1994, 1995 Institute for New Generation Computer Technology\\
(詳細は「 ICOT 無償公開ソフトウェアの利用条件」を参照して下さい。)\\
(C)1996, 1997, 1998, 1999 Japan Information Processing Development
Center\\ (配布その他は COPYRIGHT-JIPDEC ファイルを参照してください)




File: KLICj.info, Node: Top, Next: Copying, Prev: (dir), Up: (dir)

KLIC
****

KLIC とは、 KL1 を移植実装するものです。 KL1 は Guarded Horn Clauses (略
して GHC) に基づく、並行論理プログラミング言語です。KL1 の構文と意味は非
常に単純で簡潔ですが、並行計算向けの非常に強力な機能を提供しています。

* Menu:

* Copying::                     ICOT 無償公開ソフトウェアの利用条件
* Copying of JIPDEC::           JIPDEC 無償公開ソフトウェアの利用条件
* Introduction::                初めに
* Language::                    KL1 とは
* Builtin and Library::         組込み述語とライブラリ機能
* Using KLIC::                  KLIC の使い方
* Type Index::                  データ型索引
* Predicate Index::             述語、メソッド、メッセージ名索引
* Module Index::                モジュール名索引
* Concepts::                    索引

 -- The Detailed Node Listing ---

初めに

* Description::                 述語とメソッドの説明について
* Reporting Bugs::              バグ報告とコメントの送付

述語とメソッドの説明について

* Predicates and Methods::      述語とメソッド
* Messages::                    メッセージ
* Argument Modes::              引数モード

KL1 とは

* Basics::                      基本的な実行の仕組み
* Predicates::                  述語
* Modules::                     モジュール
* Goals::                       ゴール
* Initial Goal::                初期ゴール
* Generic Objects::             ジェネリック・オブジェクト
* Priority::                    優先順位の指定
* Alternatively::               節の優先関係
* Argument Pair Notation::      引数対の簡略表記
* Inline C Code::               C 言語コードのインライン挿入

ジェネリック・オブジェクト

* Creating Objects::            ジェネリック・オブジェクトの生成
* Guard Methods::               ジェネリック・オブジェクトのガード・メソッド
* Body Methods::                ジェネリック・オブジェクトのボディ・メソッド

引数対の簡略表記

* Paired Arguments::            引数対と引数対の展開
* Macros for Paired Arguments:: 引数対のためのマクロ 
* Usage of Paired Arguments::   引数対の使い方

C 言語コードのインライン挿入

* Top Insertion::               ファイル先頭でのインライン挿入
* Guard Insertion::             ガード部でのインライン挿入
* C-Level Rep::                 KL1 項の C レベル表現
* Examples of Inline::          例
* Hints of Inline::             インライン C コード機能を使う上でのヒント

組込み述語とライブラリ機能

* Common Operations::           共通操作
* Atomic Data::                 アトム・データ
* Structured Data::             構造型データ
* Executable Code::             プログラム・コードのデータとしての扱い
* Unix::                        Unix インタフェース
* Input and Output::            入出力
* System Control::              システム動作の制御
* Timer::                       タイマ
* Random Numbers::              乱数生成器

共通操作

* Unification::                 単一化
* Synchronization::             同期
* Comparison and Hashing::      比較とハッシュ
* Execution Status::            実行ステータス
* Debugging::                   デバッグ

アトム・データ

* Symbolic Atoms::              記号アトム
* Integers::                    整数アトム
* Floating Points::             浮動小数点数

記号アトム

* Notation of Atoms::           記号アトムの表記
* Symbolic Atom Operation::     記号アトムの操作

整数アトム

* Notation of Integers::        整数アトムの表記
* Integer Arith::               整数演算
* Integer Comp::                整数比較

浮動小数点数

* Notation of Floats::          浮動小数点数の生成
* Creating Floats::             新しい浮動小数点数の生成
* Floating Arith::              浮動小数点演算
* Floating Comp::               浮動小数点比較

構造型データ

* Functors::                    ファンクタ構造
* Lists::                       リスト
* Vectors::                     ベクタ
* Strings::                     文字列

ファンクタ構造

* Notation of Functors::        ファンクタの表記
* Functor Operation::           ファンクタの操作

リスト

* Notation of Lists::           リストの表記
* Merging::                     メッセージストリームの操作

ベクタ

* Notation of Vectors::         ベクタの表記
* Creating Vectors::            ベクタの生成
* Predicates on Vectors::       ベクタの述語

文字列

* Notation of Strings::         文字列の表記
* Creating Strings::            文字列の生成
* Predicates on Strings::       文字列の述語

プログラム・コードのデータとしての扱い

* Module Type::                 モジュール
* Predicate Type::              述語

Unix インタフェース

* Unix Stream::                 Unix インタフェース・ストリームの獲得
* I/O Opening::                 入出力用ストリームのオープン
* Sockets::                     ソケットの使い方
* Files & Dirs::                ファイルとディレクトリ
* Signals::                     シグナル割込みの処理
* Misc Unix Messages::          Unix ストリームへのシュシュのメッセージ
* Predicate Interface::         述語インタフェース

入出力

* C-like I/O::                  C 風のインタフェースを用いた入出力
* Prolog I/O::                  Prolog 風のインタフェースを用いた入出力

C 風のインタフェースを用いた入出力

* Common Msgs (C style)::       C 風のインタフェースを用いた共通メッセージ
* Input Msgs (C style)::        C 風のインタフェースを用いた入力メッセージ
* Output Msgs (C style)::       C 風のインタフェースを用いた出力メッセージ

Prolog 風のインタフェースを用いた入出力

* Opening Prolog I/O::          Prolog 風の I/O ストリームのオープン
* Common Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Input Msgs (Prolog style)::   Prolog 風のインタフェースを用いたメッセージ
* Output Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Wrapped Terms::               ラップシタ項

KLIC の使い方

* Compiling::                   KLIC におけるプログラムのコンパイル
* Running::                     KLIC におけるプログラムの実行
* Tracing::                     プログラム実行のトレース
* Install::                     インストール
* Distributed KLIC::            分散 KLIC
* Shared-Memory KLIC::          共有メモリ KLIC

KLIC におけるプログラムのコンパイル

* Command for Compilation::     コンパイル用コマンド
* Compiler Options::            コンパイラ・オプション
* Mechanism of Compilation::    KLIC コンパイラの動作内容

KLIC におけるプログラムの実行

* Runtime Switches::            実行時オプション

プログラム実行のトレース

* Preparing for Trace::         トレース実行の準備
* Trace Ports::                 トレース・ポート
* Output of Tracer::            トレース表示のフォーマット
* Controlling Trace::           トレース制御コマンド
* Spying::                      スパイ
* Port Control::                トレース・ポートのコマンド
* Display Control::             表示を制御するコマンド
* Dumping Goals::               ゴールのダンプ
* Misc Trace Commands::         その他のコマンド
* Perpetual Suspension::        永久中断の探索

トレース制御コマンド

* Goal Control::                トレース対象ゴールのトレース制御
* Subgoal Control::             新しく生成されたサブゴールのトレース制御
* Predicate Control::           述語毎のトレース・スイッチのデフォルト値の変更

インストール

* Configuration::               コンフィギュレーション
* Make All::                    KLIC システムのコンパイル
* Make Tests::                  コンパイル結果のテスト
* Make Install::                オブジェクトのインストール
* Make Distclean::              インストールディレクトリのクリーン・アップ
* Troubles::                    うまく行かない場合

分散 KLIC

* Installation of Distributed KLIC::        分散 KLIC のインストール
* Compiling Programs for Distributed KLIC:: 分散 KLIC 向けプログラムのコンパイル
* Running Programs of Distributed KLIC::    分散 KLIC のプログラム実行

分散 KLIC のプログラム実行

* Setting Up PVM::                          PVM のセット・アップ
* Runtime Options for Distributed KLIC::    分散 KLIC の実行時オプション
* Known Bugs of Distributed KLIC::          分散 KLIC の既知のバグ

共有メモリ KLIC 

* Installation of Shared-Memory KLIC::      共有メモリ KLIC のインストール
* Compiling Programs for Shared-Memory KLIC::   共有メモリ KLIC 向けプログラムのコンパイル
* Running Programs of Shared-Memory KLIC::  共有メモリ KLIC のプログラム実行

共有メモリ KLIC のプログラム実行

* Runtime Options for Shared-Memory KLIC::  共有メモリ KLIC の実行時オプション
* Known Bugs of Shared-Memory KLIC::        共有メモリ KLIC の既知のバグ



File: KLICj.info, Node: Copying, Next: Copying Of JIPDEC, Prev: Top, Up: Top

ICOT 無償公開ソフトウェアの利用条件
***********************************

*1. ICOT無償公開ソフトウェアの目的*

財団法人新世代コンピュータ技術開発機構 (以下、"ICOT"という) は、日本国通
商産業省より委託され、第五世代コンピュータ・プロジェクトを推進してきた。
また、平成５年度からは、このプロジェクトの後継プロジェクトとして、第五世
代コンピュータの研究基盤化プロジェクトを推進している。第五世代コンピュー
タ・プロジェクトおよびその後継プロジェクト(以下、これらの一連のプロジェ
クトを"本プロジェクトという")は、並列推論処理を中核メカニズムとする新し
いコンピュータの基礎技術を創出し、その知見と技術を世界の研究者と共有する
ことによって、コンピュータ科学の発展に貢献することを目的としている。

本プロジェクトによって、並列推論マシン、並列推論ソフトウェア技術といった
新しい技術が開発され、また、こうした技術開発に伴い、多くの先進的なソフト
ウェアが試作されている。これらのソフトウェアは、基礎的な研究開発段階にあ
るため、多くの研究者に広め発展させていくべきものである。

そこで、 ICOT は、本プロジェクトの国際貢献の目的に鑑み、著作権が国ではな
く ICOT に帰属することとなるこれらの研究開発段階のソフトウェアを、「 
ICOT 無償公開ソフトウェア」として公開してきた。これらのソフトウェアにつ
いては、研究開発のための障害となるいっさいの制約をはずすことによって、多
くの研究者の方々に自由に利用してもらい、新しいコンピュータ科学への貢献を
実践したいと考えている。

本プログラム及びドキュメント(以下、"本プログラム"という)は、" ICOT 無償
公開ソフトウェア"の 1 つとして、 ICOT において無償で配布しているものであ
る。

*2. 使用、変更、複製、配布の自由*

本プログラムの"利用者"は、その使用、変更、複製を自由に行うことができる。
ここでいう変更には、本プログラムの機能、性能、品質を向上させるために改良、
拡張を行うこと、もしくは自ら開発したプログラムやドキュメントを本プログラ
ムに追加することが含まれるが、それだけには限定されない。

本プログラムの利用者は、本「 ICOT 無償公開ソフトウェアの利用条件」第3項
(*無保証*)が記されていることを*条件として*、関連法令に違反しない限り、本
プログラムそのもの、または本プログラムの変更版を第三者へ自由に配布するこ
とが*できる*。

*3. 無保証*

本プログラムは、本プロジェクトの研究開発の試作物を『あるがまま』の状態で
提供するものである。このため、明示的であるか黙示的であるか、または法令の
規定により生ずるものであるか否かを問わず、一切の保証をつけないで提供され
るものである。ここでいう保証とは、プログラムの品質、性能、市場性、特定目
的適合性、および他の第三者の権利への無侵害についての保証を含むが、それに
限定されるものではない。

本プログラムの利用者は、本プログラムが無保証であることを承諾し、本プログ
ラムが無保証であることによるすべてのリスクを利用者自身で負うものとする。

従って、利用者が本プログラムを利用したこと、または利用できないこと、もし
くは本プログラムを利用して得られた結果に起因する一切の損害について、著作
権者である ICOT および本プログラムの開発に関与した関連機関並びにそれらの
役職員及び従業員は、そのような損害の発生する可能性について、知っていたか
否かにかかわらず、何らの責任も負わない。本プログラムの利用者は、本プログ
ラムの利用を開始したことによりこれを承諾しているものとみなされる。ここで
いう利用とは、本プログラムの使用、変更、複製、配布、二次的著作物の作成を
含むがこれらに限定されない。

利用者が本プログラムそのもの、または本プログラムの変更版を、 ICOT 以外の
第三者から配布を受けた場合においても、配布を行った第三者が独自に特別な保
証を文書で行わない限り、配布を行った第三者は、その利用者に対して、本プロ
グラムに関係する限りにおいて同様に何らの責任を負わないものとする。



File: KLICj.info, Node: Copying Of JIPDEC, Next: Copying, Prev: Top, Up: Top

JIPDEC 無償公開ソフトウェアの利用条件
*************************************

ICOTで開発されてきたKLICは、その後JIPDECのAITECにより開発が引き継がれ、
配布されています。よって、1996年以降の著作権はJIPDECにある旨記載していま
す。

JIPDECのコピーライトが附属されている部分についての改変、配布等の条件は
「ICOT無償公開ソフトウェア」のそれと同じとします。つまり、「ICOT無償公開
ソフトウェアの利用条件」の"ICOT"とある部分をJIPDECとして読み替え適用する
ようにしてください。

なお、JIPDECの著作ではないソースコードも存在しますが、それらについても同
様に「ICOT無償公開ソフトウェアの利用条件」の著作者、配布者を読み替え適用
してください。



File: KLICj.info, Node: Introduction, Next: Language, Prev: Copying Of JIPDEC, Up: Top

はじめに
********

このマニュアルでは、第五世代コンピュータの日本における国家プロジェクトに
関与した新世代コンピュータ開発機構と、その後継プロジェクトにおいて開発さ
れた KLIC と呼ばれる移植性の高い KL1 の処理系について説明します。

KL1 は Garded Horn Clauses(略して GHC )に基づく、並行論理型プログラミン
グ言語です。
 KL1 の構文と意味は非常に単純で簡潔ですが、並行計算向けの非常に強力な機
能を提供しています。

KLIC は KL1 プログラムを C プログラムにコンパイルします。その後、ホスト・
システムの C コンパイラが、 C プログラムを再配置可能なオブジェクトにコン
パイルします。続いて、再配置可能なオブジェクトは、 KLIC の実行時ライブラ
リとともに一括してリンクされます(*Note KLIC コンパイラの動作内容:
Mechanism of Compilation.)。したがって、システムはホスト・システムのハー
ドウェア・アーキテクチャに依存しません。さらに、移植性を確保するため、シ
ステムは Unix の最小機能だけを使用するように書かれています。

* Menu:

* Description::                 述語とメソッドの説明について
* Reporting Bugs::              バグ報告とコメントの送付



File: KLICj.info, Node: Description, Next: Reporting Bugs, Prev: Introduction, Up: Introduction

述語とメソッドの説明について
============================

* Menu:

* Predicates and Methods::      述語とメソッド
* Messages::                    メッセージ
* Argument Modes::              引数モード



File: KLICj.info, Node: Predicates and Methods, Next: Messages, Prev: Description, Up: Description

述語とメソッド
--------------

他の論理型プログラミング言語システムと異なり、KLIC は述語とジェネリック・
メソッドの 2 種類の手続きを提供します。述語はそれらの引数の関係を定義し、
意味は固定です。ジェネリック・メソッド(または、単にメソッド)は、適用する
*オブジェクト*が定義します。したがって、意味は適用されるオブジェクトに依
存します。

述語とメソッドの両方で同じ操作を提供するものがあります。例えば、文字列の
要素は、次の 2 つのどちらかで操作できます。

 -- ボディ述語 on builtin: string_element +STRING +INDEX -ELEMENT
 -- ボディ・メソッド on string: element +STRING +INDEX -ELEMENT

前者は、システムの組込み述語で、述語の呼出しは次のように書きます。

     MODULENAME:PREDICATENAME(ARGUMENTS, ...)

上記の述語 `string_element' の場合は、組込み述語として定義されているので、
呼出しにモジュール名は必要ありません。したがって、呼出しは次のように書き
ます。

     string_element(STRING, INDEX, ELEMENT)

一般には、モジュール名がコロン (:) とともに先に書かれ、その後に述語名が
書かれます。述語によっては引数を全く持たないものもあります。そのような場
合、引数を囲む括弧も省略します。

後者は、`文字列'クラスのオブジェクトに対して定義されるジェネリック・メソッ
ドで、メソッドの呼出しは、次のように書きます。

     generic:METHODNAME(OBJECT, OTHERARGUMENTS, ...)

上記のメソッド `element' の呼出しは次のように書きます。

     generic:element(STRING, INDEX, ELEMENT)

述語とメソッドのどちらでも同じ操作が行えます。例えば、文字列 S の 3 番目
の要素(要素番号 2 )を E にとる場合、次に示すどちらの呼出しでもできます。

     string_element(S, 2, E)
     generic:element(S, 2, E)

述語 `string_element' は、文字列の要素をとることだけのものですが、一方、
ジェネリック・メソッドの呼出しは、*類似の*オブジェクトの要素をとるために
も使えますので注意してください。例えば、ベクタ( 1 次元配列)の要素も、同
じ呼出しでとることができます。



File: KLICj.info, Node: Messages, Next: Argument Modes, Prev: Predicates and Methods, Up: Description

メッセージ
----------

KL1 プログラムは、多数の*プロセス*で構成することがよくあります。プロセス
は、頻繁に*ストリーム*を使ってお互いに交信することがあります。ストリーム
は、実際には*メッセージ*のリストです。リストは、 Lisp や類似の言語のよう
に、 *car* と *cdr* の 2 個のフィールドを持つ*コンス*・セルと呼ばれるセ
ルからなっています。したがって、メッセージ・ストリームとして使う場合、コ
ンス・セルの car にはメッセージが、cdr にはストリームの残りが入っていま
す。

KLIC システムのいくつかの標準機能も、メッセージ・ストリームのインタフェー
スを持つプロセスとして提供されます。このマニュアルで説明するそのようなメッ
セージの例を次に示します。

 -- メッセージ on C 風の入出力: putc +C

これは、 `putc' という名前のメッセージが、C 風の I/O プロセスのインタフェー
ス・ストリームへのメッセージであることを意味します。この場合、メッセージ
は C という名前の引数を 1 個持ちます。

メッセージ・ストリームにメッセージを送るために、メッセージ・ストリームを
参照する変数を、コンス・セルで具体化します。例えば、 `S' が C 風の I/O 
へのストリームで、コード 10を持つ文字を出力する場合、次のような単一化を
行います。

     S = [putc(10)|T]

ここで、変数 `T' にはストリームの残りが入るので、これ以後のストリームに
対するメッセージはすべて、この変数に送ることになります。



File: KLICj.info, Node: Argument Modes, Prev: Messages, Up: Description

引数モード
----------
述語、メソッドまたはメッセージの引数は、特定の入出力モードを持つことがあ
ります。入力引数は、述語やメソッドの呼出しで読み込まれるので、入力引数に
未定義のものがあれば中断されます。出力引数には呼出しによって値が与えられ
ます。

述語とメソッドの説明では、入力引数には `+' を、出力引数には `-' を付けて
あります。引数の中には、読み込まれないものや値が与えられないものがありま
す。そのような引数には `?' が付いています。



File: KLICj.info, Node: Reporting Bugs, Prev: Description, Up: Introduction

バグ報告とコメントの送付
========================

KLIC システムとこのドキュメントに関する、バグやコメントは、次のメイル・
アドレスに報告してください。

     `klic-bugs@icot.or.jp'.

KLIC のユーザのためのメイル・リストがあります。このメイル・リストは、既
知のバグ、バグ改修、新しいリリースなどについて、開発者からのアナウンスに
使います。同じメイル・リストをユーザ間のコミュニケーションにも使うことが
できます。メイル・リストへの申込みは、次のアドレスに送ってください。

     `klic-requests@icot.or.jp'




File: KLICj.info, Node: Language, Next: Builtin and Library, Prev: Introduction, Up: Top

KL1 とは
********

KL1 とは、 Guarded Horn Clauses(GHC) に基づいた、並行計算を記述するため
のプログラミング言語です。GHC は、並行論理プログラミング言語、またはコミッ
ティッド・チョイス言語と呼ばれる言語の系統に属しています。

他にこの系統に属する言語としては、例えば、 Concurrent Prolog、Parlog、
Fleng、Strand、Janus 等があります。これらの言語は、単純で簡潔な構文と意
味を持ちながら、並行計算向けに非常に強力な機能を提供しています。

ここでは、 KL1 言語の概略を紹介します。将来(できれば)、より正確で詳細な
記述を補う予定です。

* Menu:

* Basics::                      基本的な実行の仕組み
* Predicates::                  述語
* Modules::                     モジュール
* Goals::                       ゴール
* Initial Goal::                初期ゴール
* Generic Objects::             ジェネリック・オブジェクト
* Priority::                    優先順位の指定
* Alternatively::               節の優先関係
* Argument Pair Notation::      引数対の簡略表記
* Inline C Code::               C 言語コードのインライン挿入



File: KLICj.info, Node: Basics, Next: Predicates, Prev: Language, Up: Language

基本的な実行の仕組み
====================


次に、クイックソート・プログラムの一部を記述した、小さな KL1 プログラム
の例を示します。

例1:クイックソート

     :- module quicksort.

     sort(X, Y) :- sort(X, Y, []).

     sort([], Y, Z) :- Y = Z.
     sort([P|X], Y, Z) :-
         partition(P, X, X1, X2),
         sort(X1, Y, [P|Y1]),
         sort(X2, Y1, Z).

     partition(_, [], S, L) :-
         S = [],
         L = [].
     partition(P, [W|X], S, L) :- W =< P |
         S = [W|S1],
         partition(P, X, S1, L).
     partition(P, [W|X], S, L) :- W >= P |
         L = [W|L1],
         partition(P, X, S, L1).

最初の行 `:- module quicksort.' は、このプログラムモジュールが 
`quicksort' というモジュールであることを宣言しています(*Note モジュール:
Modules.) 。

KL1 プログラムの実行とは、(可能ならば並列に行われる)リダクションの繰返し
によって、与えられた"ゴール"がプログラム"節"で繰り返され、リダクションし
て行くことです。各節は次のような形をしています。

     PREDICATENAME(ARGUMENT PATTERN ...) :- GUARD | BODY.

ゴールがリダクションされるときには、ゴール中の述語に対応するプログラム中
の節が調べられ、引数パターンに一致する節が見つかると、そのガード部が調べ
られます。引数が一致し、ガード部の条件が満たされるような節は、リダクショ
ンに使用される候補となります。それらの候補のうちの任意の 1 つが、リダク
ションに用いられ、元のゴールは、今*選ばれた候補*のボディ部の( 0 個以上の)
ゴールによって置き換えられます。

ガード部のテストが必要ない場合、ガード部は、縦棒(|)と共に省略可能です。



File: KLICj.info, Node: Predicates, Next: Modules, Prev: Basics, Up: Language

述語
====

KL1 の"述語"は、 Fortran のサブルーチンや、 C の関数に相当します。述語は、
ヘッドが同じ述語名で同じ引数個数であるような節の集まりとして定義できます。
他のいくつかの言語と異なり、述語は名前だけでなく、"アリティ(引数個数)"に
よっても区別されます。同じ述語名でアリティが異なる述語を区別するために、
このマニュアルでは、`述語名/アリティ'という表記法を使用します。

先ほどのクイックソートのプログラムでは、`sort' という名前の 2 引数と 3 
引数の 2 つの述語が定義されていました(*Note 基本的な実行の仕組み:
Basics.)。このような述語を、 `sort/2' や `sort/3' と表します。

述語を定義する節の順序は、プログラムの意味には関係ありません。例えば、 2 
つの整数の大きい方の値を出力する述語は、次のように定義できます。
     max(X, Y, M) :- X >= Y | M = X.
     max(X, Y, M) :- X =< Y | M = Y.
@noindent

また、同じ述語を次のように節の順序を逆にして定義することもできます。
     max(X, Y, M) :- X =< Y | M = Y.
     max(X, Y, M) :- X >= Y | M = X.

ある節の集まりが適用できない`ときに限り'、他の節の集合を適用したいという
場合には、 otherwise というキーワードを 2 つの節の集合の間に書く必要があ
ります。例えば、上記の述語 `max' を次のように定義することもできます。

     max(X, Y, M) :- X >= Y | M = X.
     otherwise.
     max(X, Y, M) :- M = Y.

この述語の意味は、先ほどの例とほぼ同じですが、 `X' や `Y' が整数でない場
合には、先ほどの 2 つの例では、実行が失敗するのに対し、この述語では、 
`M' を `Y' と単一化するという点が異なっています。

`otherwise' 指示より後ろにある節は、それより前のすべての節が適用*できな
い*ことが分かるまでは調べられません。このことは、後で何らかの情報(変数の
束縛)が追加された場合でも変わりません。
 otherwise 指示と alternatively 指示を混同しないようにしてください。
`alternatively' 指示は、その指示よりも前にある節が、後ろにある節に比べて
優先的に扱われることを示すものです(*Note 節の優先関係: Alternatively.)。



File: KLICj.info, Node: Modules, Next: Goals, Prev: Predicates, Up: Language

モジュール
==========

KL1 には、大きなプログラムをいくつかのモジュールに分割するためのモジュー
ル構造があります。
 1 つのモジュールは、 1 つ以上の述語から構成されます。モジュールは、 `:-
module モジュール名.' の形のモジュール宣言で始まり、その後に述語定義の節
が続きます。
 1 つのモジュール定義は、ファイルの終わり、または別のモジュール宣言で終
了します。先ほどのクイックソートの例で、次に示す最初の行
     :- module quicksort.

は、このプログラムモジュールが quicksort であることを宣言しています
(*Note 基本的な実行の仕組み: Basics.)。

同じ名前、同じ引数個数でも、異なったモジュールで定義された述語は、異なる
述語とみなされます。したがって、モジュール名を明示することが必要な場合は、
`モジュール:述語/アリティ'という表記法が用いられます。



File: KLICj.info, Node: Goals, Next: Initial Goal, Prev: Modules, Up: Language

ゴール
======

ゴールは、KL1 の実行の単位です。ゴールは述語と結び付けられています。ゴー
ルは、述語を定義する節の 1 つを用いて、0 個以上のより単純なゴールにリダ
クションされます。

ゴールは以下のように記述されます。

     PREDICATE(ARGUMENTS, ...)

または、引数を持たない場合には、さらに簡単に

     PREDICATE

のように記述できます。

述語が同じモジュール内にない場合には、

     MODULE:PREDICATE(ARGUMENTS, ...)

または

     MODULE:PREDICATE

という構文になります。

quicksort モジュールを使う `main' モジュールは、例えば、次のようになりま
す(*Note 基本的な実行の仕組み: Basics.)。

例 2 : `quicksort' モジュールを使用

     :- module main.

     main :-
         X = [9,2,8,3,6,7,4,1,5],
         builtin:print(X),
         quicksort:sort(X, Y),
         builtin:print(Y).

上の例の `quicksort:sort(X, Y)' というボディ・ゴールは、 `quicksort' モ
ジュールの `sort/2' という述語を参照しています。



File: KLICj.info, Node: Initial Goal, Next: Generic Objects, Prev: Goals, Up: Language

初期ゴール
==========

すべての KLIC プログラムは、 `main:main' という初期ゴールから実行されま
す。つまり、 `main' モジュールで定義された、引数を持たない `main' という
述語です。モジュール `main' の例(*Note ゴール: Goals.)は、メイン・プログ
ラムの例です。コマンド行の引数は、初期ゴールには渡されません。コマンド行
引数を得るための述語は、別途用意されています(*Note 述語インタフェース:
Predicate Interface.)。



File: KLICj.info, Node: Generic Objects, Next: Priority, Prev: Initial Goal, Up: Language

ジェネリック・オブジェクト
==========================

"ジェネリック・オブジェクト"は、 KL1 に新しいデータ型やそれらの操作を追
加するための枠組みを提供します。ジェネリック・オブジェクトには、"データ・
オブジェクト"、"コンシューマ・オブジェクト"、"ジェネレータ・オブジェクト
"という 3 種類があります。

ジェネリック・オブジェクトは、疑似述語 `generic:new' によって作成されま
す。ジェネリック・データ・オブジェクトは、通常の KL1 のデータと似ていま
す。データ・オブジェクトに対する操作は、それらに対する"ジェネリック・メ
ソッド"という形で定義できます。メソッドは、疑似述語 `generic: メソッド'
によって呼び出されます。コンシューマ・オブジェクトやジェネレータ・オブジェ
クトは、通常の KL1 プログラムの変数と同じように見えるものであり、それら
に対する操作は、単一化によって暗黙のうちに行われます。

KLIC が提供する標準データ型のいくつか、例えば、ベクタや文字列等は、実際
にはジェネリック・データ・オブジェクトとして実装されています。これらに関
するジェネリック・メソッドは、組込み述語としても呼び出せるようになってい
ます。例えば、 `set_vector_element(ORIGINAL,INDEX,NEWELEMENT,NEW)' は、 
`generic:set_element(ORIGINAL,INDEX, NEWELEMENT, NEW)' と同じことを意味
します。

* Menu:

* Creating Objects::            ジェネリック・オブジェクトの生成
* Guard Methods::               ジェネリック・オブジェクトのガード・メソッド
* Body Methods::                ジェネリック・オブジェクトのボディ・メソッド



File: KLICj.info, Node: Creating Objects, Next: Guard Methods, Prev: Generic Objects, Up: Generic Objects

ジェネリック・オブジェクトの生成
--------------------------------

ジェネリック・オブジェクトは、次に示す疑似述語によって生成されます。

     generic:new(CLASSNAME, OBJECT, ARGS, ...)

CLASSNAME は、オブジェクトのクラス名を示す記号アトムです。この疑似述語の
呼出しによって、新しくジェネリック・オブジェクトが生成され、 OBJECT で指
定された変数に結び付けられます。ジェネリック・オブジェクト生成時に必要な
パラメタは、 ARGS で与えます。ARGS の意味は、それぞれのオブジェクト・ク
ラスに依存します。



File: KLICj.info, Node: Guard Methods, Next: Body Methods, Prev: Creating Objects, Up: Generic Objects

ジェネリック・データ・オブジェクトのガード・メソッド
----------------------------------------------------

ガード・メソッドを呼ぶことで、ジェネリック・データ・オブジェクトに依存し
て節が選択できます。ガード・メソッドは、以下の形式を持っています。

     generic:METHOD(OBJECT, INPUT, ...):OUTPUT:...

`INPUT, ...' では、入力引数を指定します。もし、入力引数のどれかが未定義
のままである場合には、この呼出しは中断されます。`OUTPUT:...' では、出力
引数を指定し、このメソッドからの返却値がここに入れられます。もし、 
OUTPUT が既に何らかの具体値を持っていた場合には、その値と返却値との間の
ガード・ユニフィケーションが行われます。ガード・メソッドが返却値を持たな
い場合には、コロン(:)とそれに続く OUTPUT は省略されます。



File: KLICj.info, Node: Body Methods, Prev: Guard Methods, Up: Generic Objects

ジェネリック・データ・オブジェクトのボディ・メソッド
----------------------------------------------------

ジェネリック・データ・オブジェクトに対する操作は、次に示すボディ・メソッ
ドの呼出し形式で行います。

     generic:METHOD(OBJECT, ARGS, ...)

ガード・メソッドとは異なり、入力引数と出力引数は構文的には区別されません。
また、実行時に動的に呼び出されるメソッドを決めることもできます。その場合
は、次の呼出し形式を用います。

     generic:generic(OBJECT, FUNCTOR)

この呼出し形式では、 FUNCTOR は(コンパイル時、または実行時に)
`METHOD(ARGS,...)' というファンクタ構造でなければなりません。FUNCTOR が
未定義の場合、具体化されるまで呼出は中断します。



File: KLICj.info, Node: Priority, Next: Alternatively, Prev: Generic Objects, Up: Language

優先順位の指定
==============

ゴールには、実行優先度 (Execution Priority) が付いています。実行優先度に
は、正の整数を指定します。大きな優先度を持つゴールは、(通常)小さな優先度
を持つゴールよりも先に実行されます。しかし、優先度の指定は単なる示唆にす
ぎず、実装方式によっては、優先度が厳密に守られないこともあります。

ボディ・ゴールの実行優先度は、次の形式で指定されます。

             `GOAL@priority(ABSPRIO)'
             `GOAL@lower_priority'
             `GOAL@lower_priority(RELPRIO)'

上記の ABSPRIO と RELPRIO は、負以外の整数定数、または実行時に負以外の整
数になるような変数でなければなりません。現在の実装方式では、優先度に負が
指定された場合には 0 が指定されたものとして扱われます。

priority による絶対優先度指定によって、ゴールには ABSPRIO で指定された優
先度が与えられます。@lower_priority(RelPrio) による相対優先度指定では、
ゴールは親のゴールの優先度より RelPrio だけ小さい優先度を持ちます。
`GOAL@lower_priority' という指定は、 `GOAL@lower_priority(1)' と同じ効果
を持ちます。優先度指定のないゴールは、親のゴールと同じ優先度を持ちます。

優先度の最大値は整数の最大値であり、ホスト・システムに依存します(*Note 
整数アトム: Integers.)。初期ゴール `main:main' は、ホストシステムにおい
て最大の優先度を持ちます(*Note 初期ゴール: Initial Goal.)。



File: KLICj.info, Node: Alternatively, Next: Argument Pair Notation, Prev: Priority, Up: Language

節の優先関係
============

KL1 の述語では、 2 つ以上の節が適用可能なために非決定性を持つことがあり
ます。その場合、節同士の優先関係を `alternatively' 指示によって指定でき
ます。

`alternatively' というキーワードを 2 つの節の集合の間に書いた場合、 
`alternatively' より前の節が、後ろの節よりも*優先的に*選ばれます。もし、 
`alternatively' 指示より前の節が情報不足(変数値の具体化が足りず)のため、
選択不可能な場合、この指示よりも後の節が選択の対象となります。この機能は、
実行状況に依存した投機的実行 (speculative execution) の制御に利用できま
す。

alternatively と `otherwise' を混同しないでください(*Note 述語:
Predicates.)。例えば、次の 2 つの述語を考えてみます。

     p(1, Y, R) :- R = a.
     alternatively.
     p(X, 2, R) :- R = b.

     q(1, Y, R) :- R = a.
     otherwise.
     q(X, 2, R) :- R = b.

第 1 引数が未定義で、第 2 引数が `2' の場合、述語 `p' は 2 番目の節の実
行によって第 3 引数に `b' を返しますが、述語 `q' は第 1 引数が束縛される
まで待ちます。つまり、第 1 引数が最終的に `1' になるならば、述語 `q' で
は `a' が返されることが保証されますが、述語 `p' では `a' か `b' のどちら
かが返されることになります。



File: KLICj.info, Node: Argument Pair Notation, Next: Inline C Code, Prev: Alternatively, Up: Language

引数対の簡略表記
================

KL1 のプログラムでは、述語に対して 1 つを入力、 1 つを出力というように
 2 つの引数を対として与えることがよくあります。KLIC では、このような場合
のために簡略表現を用意しています。

* Menu:

* Paired Arguments::            引数対と引数対の展開
* Macros for Paired Arguments:: 引数対のためのマクロ 
* Usage of Paired Arguments::   引数対の使い方



File: KLICj.info, Node: Paired Arguments, Next: Macros for Paired Arguments, Prev: Argument Pair Notation, Up: Argument Pair Notation

引数対と引数対の展開
--------------------

述語のヘッドや、ガード部やボディ部にあるゴールに対して、 1 つの変数名を
マイナス符号で続けることで、引数対を与えることができます。この疑似変数名
は、マクロ展開のために用いられる変数名であり、通常の KL1 の変数と区別す
るために"引数対名"と呼びます。次に例を示します。

     p(X,Y)-Pair :- q(X)-Pair, s(Z)-Pair, r(Pair,Y), t(Z)-Pair.

この場合、疑似変数 `Pair' が引数対名です。この節は、次の節と同じであると
解釈されます。

     p(X,Y,P0,P) :- q(X,P0,P1), s(Z,P1,P2), r(P2,Y), t(Z,P2,P).

ヘッドやゴールに付いているマイナス符号に続く引数対名は、引数列の最後に追
加された 2 つの異なった変数の対と解釈されます。これ以後、この 2 つの変数
を、引数対から生成された"展開対"と呼びます。

あるゴールの中の展開対の 2 番目の変数は、次の同じ引数対名を持つゴールの
展開対の 1 番目の変数と同じです。上の例では、 `P1' はゴール `q/3' の第 3 
引数に現れ、また `s/3' の第 2 引数にも現れています。これらは、元々同じ引
数対名 `Pair' だったものです。

ヘッドにある展開対の 1 番目の変数は、節内で同じ引数対名を持つ最初のゴー
ルの展開対の 1 番目の変数と同じです。またヘッドにある展開対の 2 番目の変
数は、節内で同じ引数対名を持つ最後のゴールの展開対の 2 番目の変数と同じ
です。

上の例では、ヘッドにある展開対の 1 番目の変数 `P0' が、最初のゴール 
`q/3' の第 2 引数にも現れており、ヘッドにある展開対の 2 番目の変数 `P' 
は、最後のゴール `t/3' の第 3 引数にも現れています。

引数対名がヘッドにしか現れていない場合には、展開対の 2 つの変数がボディ
において単一化されるコードが生成されます。例えば、

     p(X)-Y :- q(X).

は、次のように展開されます。

     p(X,Y0,Y) :- Y0=Y, q(X).

先ほどの例では、ゴール `r/2' の 1 番目の引数に見られるように、引数対名は、
ヘッドやボディにマイナス符号を付けて指定されるだけでなく、通常の引数位置
に置かれることもあります。この場合、引数対名は、単一の変数に展開されます。
この変数は、直前の展開対の 2 番目の変数と同じで、直後の展開対の 1 番目の
変数とも同じです。したがって、この例では、 `r/2' の第 1 引数 `Pair' は 
`P2' に展開され、これは `s/3' の第 3 引数および `t/3' の第 2 引数と同じ
になります。

ゴールやヘッドには、任意の数の引数対名が書けます。例えば、次の例で、

     p-X-Y :- q-X, r-Y, s-Y-X.

は、次のように解釈されます。

     p(X0,X,Y0,Y) :- q(X0,X1), r(Y0,Y1), s(Y1,Y,X1,X).

時には、通常の引数を引数対名の後に指定したくなる場合もあるでしょう。その
場合には、プラス符号 `+' の後ろに通常の引数を付けることで指定できます。
例えば、

     p-X+Y :- q-X+35, r(Y), s+Y-X.

は、次のように解釈されます。

     p(X0,X,Y) :- q(X0,X1,35), r(Y), s(Y,X1,X).

以上、述べた引数対の展開規則は、ゴールの位置に依存することに注意してくだ
さい。しかし、これによってボディ・ゴールの実行順序が何らかの制約を受ける
ことを意味するものでは全く*ありません*。

引数対の記法は、節のマクロ展開にすぎないということも覚えておいてください。
 1 つの述語のいくつかの節を引数対の記法を用いて書き、他の節は通常の記法
で書くことも可能です。



File: KLICj.info, Node: Macros for Paired Arguments, Next: Usage of Paired Arguments, Prev: Paired Arguments, Up: Argument Pair Notation

引数対のためのマクロ
--------------------

KLIC では、引数対をより多くの場面で利用するため、次のようなマクロを用意
しています。

S <= M
     `S0 = [M|S1]' に展開されます。 S0 と S1 は引数対名 S を展開した展開
     対です。

M => S
     `[M|S0] = S1' に展開されます。 S0 と S1 は引数対名 S を展開した展開
     対です。

S += E
S -= E
S *= E
S /= E
      `S1 := S0 + E0' 等に展開されます。 S0 と S1 は引数対名 S を展開し
     た展開対です。

S <== X
     `S1 = X' に展開されます。 S0 と S1 は引数対名 S を展開した展開対で
     す。 S0 は展開型には現れません。つまり、元々の引数対 S の値は失われ
     ます。その代わり、次から現れる S は X を意味することになります。こ
     のマクロは、通常、引数対が対にならずに出現する場合に用いられます。
     例えば、

          ..., p-S, q(S), S <== X, r-S, ...

     は、次のことを意味します。

          ..., p(S0,S1), q(S1), S2 = X, r(S2,S3), ...



File: KLICj.info, Node: Usage of Paired Arguments, Prev: Macros for Paired Arguments, Up: Argument Pair Notation

引数対の使い方
--------------

ここでは、引数対の標準的な使用例をいくつか示します。

次のプログラムは、整数リストの各要素を加え合わせるプログラムです。

     sum(List,Sum) :- sum(List)+0+Sum.

     sum([])-Acc.
     sum([H|T])-Acc :- Acc += H, sum(T)-Acc.

ここでは、引数対 `Acc' はアキュムレータの役割を果たします。

次のプログラムは、整数リストの各要素の符号を反転します。

     inv(List,Inv) :- inv(List)+Inv-[].

     inv([])-Inv.
     inv([H|T])-Inv :- MH := -H, Inv <= MH, inv(T)-Inv.



File: KLICj.info, Node: Inline C Code, Prev: Argument Pair Notation, Up: Language

C 言語コードのインライン挿入
============================

インライン C コード機能によって、 KL1 プログラム中にオブジェクト・コード
の中に埋め込む C プログラムが記述できます。この機能は、 C における `asm' 
文に多少似ています。

挿入された C コードが適切なものであるか否かは、 KLIC システムの内部実装
方法に完全に依存します。そして、これは将来変わるかもしれません。したがっ
て、*一般ユーザがこの機能を使うことは勧められません。*

* Menu:

* Top Insertion::               ファイル先頭でのインライン挿入
* Guard Insertion::             ガード部でのインライン挿入
* C-Level Rep::                 KL1 項の C レベル表現
* Examples of Inline::          例
* Hints of Inline::             インライン C コード機能を使う上でのヒント



File: KLICj.info, Node: Top Insertion, Next: Guard Insertion, Prev: Inline C Code, Up: Inline C Code

ファイル先頭でのインライン挿入
------------------------------

ソース・ファイルの先頭では、以下の方法によって C プログラムに挿入される
文字列が指定できます。

     :- inline:"挿入されるべきCプログラム・テキスト".

オブジェクトの C プログラム中では、ここで指定したテキストは、標準的な宣
言の後で、かつユーザが定義したモジュールの前に挿入されます。

インライン指定は、いくつも書くことができます。標準的な例を次に示します。

     :- inline:"#include <stdio.h>"

挿入される C プログラムは、 KLIC の文字列定数として書く必要があるので、C 
中の二重引用符文字は、バックスラッシュ (\) によってエスケープする必要が
あります。典型的な例は次のとおりです。

     :- inline:"#include \"myheader.h\""

この部分で、節のガード部に書くインライン・コードで使用するマクロや関数を
定義しておくのは、良い考えかもしれません。



File: KLICj.info, Node: Guard Insertion, Next: C-Level Rep, Prev: Top Insertion, Up: Inline C Code

ガード部でのインライン挿入
--------------------------

次に示す形式のどちらかを使って、ガード・ゴールでもインライン挿入が指定で
きます。

     inline:"Cプログラム・テキスト"
     inline:"Cプログラム・テキスト":[ARGSPEC, ...]

どちらの形式でも、プログラム・テキスト文字列中のパーセント記号 (`%') が
特別なフォーマットを指定することの他は、 C プログラムのテキストは指定し
たとおり、ガード部に対応するオブジェクト・コード中に挿入されます。次の表
に、パーセント記号の後ろに指定される特殊なフォーマット文字とその意味を列
挙します。

数字
     数字番目(ゼロから始まる)の ARGSPEC に対応する C 変数の名前。10 個ま
     での引数しか許されないので注意してください。

f
     この節が失敗や中断した場合に、分岐する `goto' の分岐先ラベルの名前

%
     パーセント文字自身

ARGSPECは、次のいずれかの形式です

変数+型
     挿入されたプログラム・テキストが、変数の値を使用することを指示しま
     す。オブジェクト・コードには、コンパイラによって、同期と型チェック
     のために必要なコードが生成されます。

変数-型
     挿入されたプログラム・テキストによって変数に値が与えられることを意
     味します。この変数は、ここで最初に出現するものでなければなりません。
     コンパイラは挿入されたコードを実行した後は、変数が型の値を持つと、
     仮定されます。

型フィールドは、以下のいずれかでなければなりません。

any
     未束縛の変数を含む任意のもの
bound
     任意の束縛されているもの
atomic
     アトム値(アトムまたは整数)
int
     整数
atom
     記号アトム
list
     リスト構造
functor
     ファンクタ構造(ジェネリック・オブジェクトを含む)
object
     ジェネリック・データ・オブジェクト
object(Class)
     クラスが CLASS であるようなジェネリック・データ・オブジェクト

`any' 以外の型では、間接表現は取りません。入力モード (`+') 引数では、コ
ンパイラが出力するコードによって、挿入されたプログラム・テキストが実行さ
れる時点では、引数は間接参照ではなく、指定した型の値そのものであることが
保証されています。逆に、出力モード (`-') 引数では、挿入されたプログラム・
テキストの実行後は、その変数の値は間接参照ではなく、指定した型の値そのも
のであるとコンパイラは仮定しており、この情報を最適化のために利用します。
もし、出力変数に関するこの仮定に確信が持てない場合には、効率は悪いが安全
な型として `any' を指定してください。



File: KLICj.info, Node: C-Level Rep, Next: Examples of Inline, Prev: Guard Insertion, Up: Inline C Code

KL1 項の C レベル表現
---------------------

KL1 変数に対応する C の変数の型は、 KL1 のデータ型から推測される C の型
とは違うことに注意してください。

KL1 変数に対応する C の変数はすべて、 1 ワードを占めるという以外の意味を
持たない `q' という型を持ちます。また、 KL1 の値は(タグが付加される等に
よって)エンコードされています。例えば、 KL1 における整数 3 は、 C の整数 
3 とは*異なった*ビットパターンを持ちます。

このドキュメントは、 KLIC におけるデータ表現形式の詳細を表すことを目的と
したものではありませんし、そのような記述や、それに依存するプログラムは、
将来の KLIC の版では、使えなくなるでしょう。しかしながら、インライン機能
を用いて書かれるほとんどの C のプログラムにおいて、整数値の操作は最も簡
単で役に立つものなので、整数のためのデータ変換用マクロを以下に説明します。
これらは将来のバージョンにおいても変更されることはないでしょう。

C の変数から KL1 の整数値に対応する整数値を得るには、`intval(X)' という
マクロを用います。C の整数を KL1 表現にするには、`makeint(N)' を用います。



File: KLICj.info, Node: Examples of Inline, Next: Hints of Inline, Prev: C-Level Rep, Up: Inline C Code

例
--

*例1: 2 つの整数の加算*

 2 つの整数は、次の節によって加算できます。

         p(X,Y,Z) :- W := X+Y | Z = W.

同じ機能は、次のようにインライン機能を用いて実現できます。

     p(X,Y,Z) :-
       inline:"%2 = makeint(intval(%0)+intval(%1));":
         [X+int, Y+int, W-int] | Z=W.

挿入されるテキストは、次のようになります。

     x0 = makeint(intval(a0)+intval(a1));

変数 `a0' と `a1' は KL1 プログラムの `X' と `Y' に対応し、 `x0' は `W' 
に対応します。

*例 2: 2 つの整数の比較*

 2 つの整数は、次の節によって比較できます。

     p(X,Y) :- X > Y | ...

同じことは、インライン機能を用いて次のように実現できます。

     p(X,Y) :-
       inline:"if (intval(%0) <= intval(%1)) goto %f;":
         [X+int, Y+int] | ...

挿入されるテキストは、次のようになります。

     if (intval(a0) <= intval(a1)) goto p_2_interrupt;

変数 `a0' と `a1' は、 KL1 プログラムの `X' と `Y' に対応し、 
`p_2_interrupt' はコンパイラによって自動的に生成されたラベルです。



File: KLICj.info, Node: Hints of Inline, Prev: Examples of Inline, Up: Inline C Code

インライン C コード機能を使う上でのヒント
-----------------------------------------

   * できる限りインライン機能を使うのは避けてください。 KL1 の版によって
     は、コードが使えなくなるかもしれません。

   * 複数の行を連続して挿入する場合には、 1 回のインライン記述にそれらす
     べてを書いてください。そうでないと、コードの間にガードのための他の
     コードが割り込むかもしれません。挿入するプログラム・テキストには改
     行を入れることが許されています。

   * 二重引用符やバックスラッシュの前にはバックスラッシュを付けることを
     忘れないでください。Hello, world と出力したいならば、次のように書く
     必要があります。

          hello :-
              inline:"printf(\"Hello, world\\n\");" |
              ...

     二重引用符の前のバックスラッシュと `n' の前の 2 つのバックスラッシュ
     に注意してください。もし `n' の前にバックスラッシュを 1 つしか付け
     ないと、インライン展開の結果、これは改行コードとなってしまいます。
     この改行コードは展開された C プログラムの中で文字定数内に入り、途中
     で改行された文字列となります。幸運にもこの場合は、バックスラッシュ
     を 2 つ入れた場合と同じように動きますが、 C コンパイラによっては警
     告メッセージが出力されるかもしれません。

   * もし、インライン・コードを含むプログラムが期待どおりに動かない場合
     には、生成された C コードを調べることが、問題を見つける最良の方法か
     もしれません。




File: KLICj.info, Node: Builtin and Library, Next: Using KLIC, Prev: Language, Up: Top

組込み述語とライブラリ機能
**************************

この章では、 KLIC の組込み述語とライブラリ機能について説明します。

* Menu:

* Common Operations::           共通操作
* Atomic Data::                 アトム・データ
* Structured Data::             構造型データ
* Executable Code::             プログラム・コードのデータとしての扱い
* Unix::                        Unix インタフェース
* Input and Output::            入出力
* System Control::              システム動作の制御
* Timer::                       タイマ
* Random Numbers::              乱数生成器



File: KLICj.info, Node: Common Operations, Next: Atomic Data, Prev: Builtin and Library, Up: Builtin and Library

共通操作
========

述語には、すべてのデータ型に共通するものや依存しないものなどがあります。

* Menu:

* Unification::                 単一化
* Synchronization::             同期
* Comparison and Hashing::      比較とハッシュ
* Execution Status::            実行ステータス
* Debugging::                   デバッグ



File: KLICj.info, Node: Unification, Next: Synchronization, Prev: Common Operations, Up: Common Operations

単一化
------
 -- ガード述語 on builtin: = ?X ?Y
      X と Y が単一化可能か否かをチェックします。この述語の結果は、他の
     節で説明する変数には影響しません。

 -- ボディ述語 on builtin: = ?X ?Y
      X と Y を単一化します。
      X が未定義で、かつ Y が具体値である場合、
      X を Y と同じ値にします。
      Y が未定義で、かつ X が具体値である場合、
      Y を X と同じ値にします。両方が未定義の場合、2 つの変数は、同じ変
     数を意味するようになります。両方が具体値の場合、マッチング処理を行
     います。両方が同じ種類のデータ構造の場合、この単一化操作を、2 つの
     構造の対応する要素に対して再帰的に行います。



File: KLICj.info, Node: Synchronization, Next: Comparison and Hashing, Prev: Unification, Up: Common Operations

同期
----
 -- ガード述語 on builtin: wait +X
      X が具体化されるまで待ちます。



File: KLICj.info, Node: Comparison and Hashing, Next: Execution Status, Prev: Synchronization, Up: Common Operations

比較とハッシュ
--------------
 -- ガード述語 on builtin: compare +X +Y -R
      X と Y を比較し、R へ結果を返します。
      X < Y の場合、R < 0 の整数値にします。
      X = Y の場合、R = 0 にします。
      X > Y の場合、R > 0 の整数値にします。

     比較は、以下に示した標準順序に従って行います。この述語では、色々な
     型のデータが比較できます。
      X と Y の両方が同じ数値型の場合、通常の数値比較を行います。ただし、
     整数と浮動小数点数は、同じ型ではないので注意してください。このよう
     な比較を行なっても意味が*ありません*。文字列の場合は、(いわゆる)辞
     書式順序で比較します。

     型の異なる任意の 2 つのデータの順序は、システムによって定義されます。
     ただし、この順序付けは、単独の実行可能プログラム内でしか保証しませ
     ん。この述語が提供する順序付けを使用して、データ列をファイルに保存
     しても、プログラムを、再コンパイルしたり、他のプログラムとリンクし
     たりすると、そのプログラムには、データ列を順序どおりに認識するとい
     う保証がなくなってしまいます。プログラムが異なると当然、順序付けも
     異なってきます。

     比較を行うためには、X と Y がともに、十分具体化されていなければなり
     ません。例えば、`f(V) @< f(W)' は、`V' と `W' の両方が具体化されな
     い限り、比較の処理を中断します。これに対し、`f(1,V) @< f(2,W)' は、
     `V' や `W' の値を調べるまでもなく、順序が決定できるので成功します。

     データ型によっては、結果 R の絶対値が意味を持つ場合があります。2 つ
     の文字列の比較の場合、結果 R の絶対値は、最初に異なる要素位置を示す
     (Cの`strcmp'の)インデックスよりも 1 つ大きな値になります。

     ジェネリック・オブジェクトは、比較メソッドを実装しない場合がありま
     す。このような場合、その比較は、重大エラーを引き起こすことになりま
     す。

 -- ガード述語 on builtin: @< +X +Y
 -- ガード述語 on builtin: @=< +X +Y
 -- ガード述語 on builtin: @>= +X +Y
 -- ガード述語 on builtin: @> +X +Y
     標準順序で X と Y を比較します。条件を満たさない場合、述語の呼出し
     は失敗します。

 -- ガード述語 on builtin: \= +X +Y
      X と Y を比較し、主ファンクタが異なる場合だけ成功します。アトム値
     の場合、それらが異なるアトムであることを意味します。ファンクタ構造
     の場合、それらが異なるファンクタ名を持つか、または異なる引数個数を
     持つか、のどちらかであることを意味します。ジェネリック・オブジェク
     トの場合、2 つのオブジェクトが異なるクラスのときに成功します。

     `f(a) \= f(b)' は、2 つの項が同じ主ファンクタを持つ場合、失敗するの
     で注意してください。浮動小数点数はジェネリック・オブジェクトなので、
     任意の 2 つの浮動小数点数が同じクラスのオブジェクトの場合、`X \= Y' 
     は失敗するのでこの場合にも注意してください。

 -- ガード述語 on builtin: hash +X -H
      X のハッシュ値を計算し、その結果を H へ返します。ハッシュ値は、負
     以外の整数値です。

     ハッシュ機能は、構造型データの要素を再帰的に調べます。ハッシュ値を
     計算するには、X は、十分に具体化されていなければなりません。ジェネ
     リック・オブジェクトは、ハッシュ・メソッドを実装しない場合がありま
     す。このような場合、そのハッシュ値は定数値となります。



File: KLICj.info, Node: Execution Status, Next: Debugging, Prev: Comparison and Hashing, Up: Common Operations

実行ステータス
--------------

 -- ガード述語 on builtin: current_priority -P
     リダクションしたゴールの優先順位の値を P へ返します。優先順位の仕組
     みについての詳細は、*Note 優先順位の指定: Priority。

 -- ボディ述語 on builtin: current_node -NODE -NUMNODES
     並列実装では、述語を実行するノード番号を NODE へ、使用可能な実行ノー
     ド総数を NUMNODES へ返します。初期ノード番号は、0 です。このため、
     NODE へ返す最大値は、NUMNODES へ返す値より小さくなります。逐次実装
     では、NODE へ 0 を、NUMNODES へ 1 を返します。



File: KLICj.info, Node: Debugging, Prev: Execution Status, Up: Common Operations

デバッグ
--------

 -- ボディ述語 on builtin: unbound ?X -RESULT
      X が、未定義変数か否かをチェックし、その結果を RESULT へ返します。

     X が未定義変数でない場合、RESULT には、形式 {X} の単一要素のベクタ
     を単一化します。
      X が構造体の場合、その要素が未定義変数でない、という保証はありませ
     ん。

     X が未定義変数の場合、RESULT には、形式 {ADDR1, ADDR2, X} の 3 つの
     要素ベクタを単一化します。ADDR1 と ADDR2 は、変数 X の現在のアドレ
     スを示す整数となります。変数のアドレスは、ガーベージ・コレクション、
     並列実装における自動データ移動、または低レベル実装などによって、変
     化するので注意してください。これらは、デバッグする上では、ヒント以
     上の情報にはなり得ません。

     *通常のアプリケーション・プログラムでは、この述語を使用してはなりません。*  
     逐次 Prolog の `var/1' 機能とは異なり、並列実装では、未定義であると
     判断された直後に、未定義でなくなる可能性があります。したがって、こ
     の述語の使用は、システム実装の低レベルを詳細に調べる、デバッグツー
     ルのようなプログラムに限定されます。




File: KLICj.info, Node: Atomic Data, Next: Structured Data, Prev: Common Operations, Up: Builtin and Library

アトム・データ
==============

KLIC は、数値と記号の 2 種類のアトム・データ型を提供します。

KLIC は、数値データに対し、整数と浮動小数点数のデータ型、およびそれらを
操作する演算を提供します。浮動小数点数は、ジェネリック・オブジェクトとし
て実装されているため、実際にはアトムではありません。

整数データと浮動小数点データ間では、暗黙の型変換は行わないので注意してく
ださい。整数と浮動小数点数は、完全に別個のものとして扱います。

データがアトムか否かは、次のガード述語でテストします。

 -- ガード述語 on builtin: atomic +X
      X がアトムか否かをテストします。この述語では、浮動小数点数は、アト
     ムとして判定*しません*。

* Menu:

* Symbolic Atoms::              記号アトム
* Integers::                    整数アトム
* Floating Points::             浮動小数点数



File: KLICj.info, Node: Symbolic Atoms, Next: Integers, Prev: Atomic Data, Up: Atomic Data

記号アトム
----------

"記号アトム"(symbolic atoms)は、概念に名前を与えるアトム・データです。同
じ名前を持つ記号アトムは同じものであり、異なる名前を持つ記号アトムは異な
るものとなります。

* Menu:

* Notation of Atoms::           記号アトムの表記
* Symbolic Atom Operation::     記号アトムの操作



File: KLICj.info, Node: Notation of Atoms, Next: Symbolic Atom Operation, Prev: Symbolic Atoms, Up: Symbolic Atoms

記号アトムの表記
................

記号アトムの表記は、次に示すように Edinburgh Prolog に似ています。

   * 先頭がアルファベットの小文字で、そのあとに任意個(ゼロ個を含む)の文
     字、数字 、または下線の並びが続きます。

     例:
          icot   kl1   a_symbolic_atom_with_a_long_name

   * 特殊文字の並び(`~',`+',`-',`*',`/',
      `\',`^',`<',`>',`=',``'(backquote),
      `:',`.',`?',`@',`#',`$',`&').

     例 :
          +   >=   :-   =:=

   * 単一引用符で囲まれた任意の文字の並び単一引用符が文字の並びに含まれ
     る場合は、 2 個続けるか、またはバックスラッシュ (\) を前に付けてエ
     スケープします。

     例 :
          'Hello world'    'an atom with \'singlequotes\' in it'

   *  1 文字の特殊アトムには `!'、`|'、および `;' の 3 種類があります。
     なお、`|' はリスト表記では、特別な意味を持っています( *Note リスト
     の表記: Notation of Lists.)。

   * 特殊アトムの `[]' は通常、リストの終端を表わすために使用します(
     *Note リスト: Lists. )。
      `[' と `]' の間には、空白を許しています。

Edinburgh Prolog の構文と異なる点のうち、重要なものを以下に示します。

   * 縦棒(`|')は、 1 文字アトムを表します。演算子として使用する場合でも、
     セミコロン(`;')と同じ扱いは*せず*、異なるアトムとして扱います。

   *  1 対の中括弧(`{}')は、記号アトムではありません。要素のないベクタを
     表します(*Note ベクタの表記: Notation of Vectors.)。



File: KLICj.info, Node: Symbolic Atom Operation, Prev: Notation of Atoms, Up: Symbolic Atoms

記号アトムの操作
................

データが記号アトムか否かは、次のガード述語でテストします。

 -- ガード述語 on builtin: atom +X
     X が記号アトムか否かをテストします。

記号アトムの一意性を保持するために、処理系では、各記号アトムに一意な番号
を付けて、記号アトムの名前文字列と記号アトム番号との関係を保持しています。
記号アトムと名前の関係は、`atom_table' モジュールで定義した次の述語によっ
て調べることができます。

 -- 述語 on atom_table: make_atom +STRING -ATOM
     STRING が与えられたとき、その名前を持つ ATOM を返します。そのような
     記号アトムが存在しない場合、新しい記号アトムを登録します。

 -- 述語 on atom_table: atom_number +ATOM -NUMBER
     ATOM の内部表現で利用している通し番号を、整数で NUMBER へ返します。

 -- 述語 on atom_table: get_atom_string +ATOM -STRING
     ATOM の名前文字列を STRING へ返します。

 -- 述語 on atom_table: intern +STRING -RESULT
     返却値が `normal(ATOM)' 形式のファンクタ構造である他は、
     atom_table:make_atom と同じです。

 -- 述語 on atom_table: get_atom_name +ATOM -RESULT
     返却値が `normal(STRING)' 形式のファンクタ構造である他は、
     atom_table:get_atom_string と同じです。

記号アトムは名前文字列を持っていますが、それらの名前文字列を、文字列操作
のために使用すべきでは*ありません*。文字列データは、より豊富な機能性と、
より良い性能を提供しています(*Note 文字列: Strings.)。



File: KLICj.info, Node: Integers, Next: Floating Points, Prev: Symbolic Atoms, Up: Atomic Data

整数アトム
----------

KLIC は、基本的な標準機能として、通常、28 ビットか 60 ビットの整数データ
を提供します。そのビット長は、使用する C コンパイラに依存します。 整数デー
タは、 `long int' 型のビット長に比べ、4 ビット短くなります。

 -- ガード述語 on builtin: integer +X
     X が整数アトムか否かをテストします。

* Menu:

* Notation of Integers::        整数アトムの表記
* Integer Arith::               整数演算
* Integer Comp::                整数比較



File: KLICj.info, Node: Notation of Integers, Next: Integer Arith, Prev: Integers, Up: Integers

整数の表記
..........

KLIC は、整数定数を表す方法を提供します。
   * 通常の 10 進表記:任意指定のマイナス符号のあとに、10 進数字の並びを
     続けます。例:`123',`-35' 。
   * 基数表記:任意指定のマイナス符号のあとに、基数を規定する 10 進数字の
     並び (1〜36) 、アポストロフィ、そして、数字とアルファベット(大文字、
     小文字の区別なし)からなる基数の数字列を続けます。例 : `2'1010'、
     `16'0D0a' 。基数 1 の整数の値は、数字列中の 1 の数です。例えば、
     `1'10110' は 3 を表します。

   * 文字コード表記:任意指定のマイナス符号のあとに、数字の 0、アポストロ
     フィと文字を続けます。例:`0'a' は、アルファベットの小文字の `a' の
     文字コードを表します。上記の定数表記は、KL1 プログラムと、Prolog 風
の入出力インタフェースで読み込まれる KL1 データの双方で使用できます
(*Note Prolog 風のインタフェースを用いた入出力: Prolog I/O.)。

以下に示す内容も PIM マシン上の PIMOS システムとの互換性のために、 KL1 
プログラムは許しています。
   * 基数表記:任意指定のマイナス符号のあとに、基数を規定する 10 進数字の
     並び (1〜36) 、シャープ記号 (#) 、そして、数字とアルファベット(大文
     字、小文字の区別なし)からなる基数の数字列を二重引用符で囲んで続けま
     す。例:`2#"1010"'、`16#" 0D0a"' 。
   * 文字コード表記:任意指定のマイナス符号のあとに、シャープ記号(#)と、
     二重引用符で囲んだ 1 個の文字を続けます。例:`#"a"' は、アルファベッ
     トの小文字の `a' の文字コードを表します。



File: KLICj.info, Node: Integer Arith, Next: Integer Comp, Prev: Notation of Integers, Up: Integers

整数演算
........

 -- ガード述語 on builtin: := -VAR +EXPR
 -- ボディ述語 on builtin: := -VAR +EXPR
     整数式 EXPR の値を計算し、VAR と単一化します。次の演算子が利用可能
     です。

     X + Y
          加算
     + X
          演算せず X が結果となります
     X - Y
          減算
     - X
          符号の反転
     X * Y
          乗算
     X / Y
          整数除算
     X mod Y
          モジュロ
     \(X)
          ビットごとの補数
     X /\ Y
          ビットごとの論理積
     X \/ Y
          ビットごとの論理和
     X xor Y
          ビットごとの排他的論理和
     X << Y
          左論理シフト
     X >> Y
          右論理シフト
     int(X)
          浮動小数点から整数への変換 　
           X は浮動小数点式で、その値を整数値に丸めます(*Note 浮動小数点
          演算: Floating Arith.)。

     算術オーバフローは無視します。つまり、すべての演算は、使用する Cコ
     ンパイラに依存して、モジュロ2**28 か モジュロ 2**60を行います。32ビッ
     トの `long int' を持つ Cコンパイラは、28ビットの KLIC 整数を提供し、
     64ビットの `long int' を持つ Cコンパイラは、60ビットの KLIC 整数を
     提供します。

     この述語は、節のガードとボディの両方で利用可能です。

     式中に、具体化されていないオペランドがある場合、すべてのオペランド
     が具体化されるまで計算は中断します。

     式中のいくつかのオペランドに対して、再帰的に式を指定できます。ただ
     し、プログラム中に変数として書くオペランドは、 `3+5' のような合成項
     に具体化しては *なりません*。具体化するのは整数だけにしてください。
     整数以外に具体化すると、型不一致のエラーが発生します。



File: KLICj.info, Node: Integer Comp, Prev: Integer Arith, Up: Integers

整数比較
........

整数データの比較は、ここで説明する述語を用いて行うことができます。より一
般的な比較述語も提供しています(*Note 比較とハッシュ: Comparison and
Hashing.)。ただし、ここで説明する述語とメソッドは、オペランドが整数であ
ることが明らかな場合に使用すると、より効率的です。

 -- ガード述語 on builtin: > +X +Y
 -- ガード述語 on builtin: >= +X +Y
 -- ガード術語 on builtin: =:= +X +Y
 -- ガード述語 on builtin: =\= +X +Y
 -- ガード述語 on builtin: =< +X +Y
 -- ガード述語 on builtin: < +X +Y

     これらは 2 つの整数引数の比較演算を行います。値の同値関係のチェック
     には `=:=' と `=\=' を使用してください。比較の両側には算術式が指定
     できます。`:=' で用いたものと同じ演算子群が使えます。



File: KLICj.info, Node: Floating Points, Prev: Integers, Up: Atomic Data

浮動小数点数
------------

64 ビット精度の浮動小数点数を、ジェネリック・オブジェクトとして提供しま
す。次のメソッドと述語は、与えられたデータが浮動小数点数か否かを判定しま
す。

 -- ガード・メソッド on float: float +X
 -- ガード述語 on builtin: float +X
     X が浮動小数点数か否かをテストします。

* Menu:

* Notation of Floats::          浮動小数点数の生成
* Creating Floats::             新しい浮動小数点数の生成
* Floating Arith::              浮動小数点演算
* Floating Comp::               浮動小数点比較



File: KLICj.info, Node: Notation of Floats, Next: Creating Floats, Prev: Floating Points, Up: Floating Points

浮動小数点数の表記
..................

浮動小数点数は、次のような定数表記の構文を持っています。

     符号 整数 `.' 小数 `e' 符号 指数

ここで、整数、小数、および指数は、10進数の並びです。符号は、 `+' 、 `-' 
または 指定なし(この場合、 `+' を仮定する)となります。指数部は、文字の 
`e'、符号、および指数で構成し、すべてを省略することも可能です。

浮動小数点定数の例を以下に示します。

     3.14159 -6.02e23  1234.5678e-25


File: KLICj.info, Node: Creating Floats, Next: Floating Arith, Prev: Notation of Floats, Up: Floating Points

新しい浮動小数点数の生成
........................

新しい浮動小数点数は、次のように生成できます。
*Note 浮動小数点演算: Floating Arithで説明する浮動小数点の演算用述語も、算術演算の結果として浮動小数点数を生成します。

 -- float on オブジェクト生成: new -FLOAT +INIT
     新しい浮動小数点数を生成し、 FLOAT で単一化します。引数の INIT には、
     浮動小数点数の値として整数を指定する必要があります。例えば、 
     `generic:new(float, F, 3)' では `F' を `3.0' で単一化します。



File: KLICj.info, Node: Floating Arith, Next: Floating Comp, Prev: Creating Floats, Up: Floating Points

浮動小数点演算
..............

 -- ボディ述語 on builtin: $:= -VAR +EXPR
     浮動小数点式の値 EXPR を計算して VAR で単一化します。次の演算子が利
     用可能です。

     X + Y
          加算
     X - Y
          減算
     X * Y
          乗算
     X / Y
          除算
     pow(X, Y)
          X の Y 乗
     sin(X), cos(X), tan(X)
          X の三角関数
     asin(X), acos(X), atan(X)
          X の逆三角関数
     sinh(X), cosh(X), tanh(X)
          X の双曲線関数
     exp(X)
          指数関数
     log(X)
          自然対数
     sqrt(X)
          平方根
     ceil(X)
          切り上げ関数(正の無限方向への切り上げ)
     floor(X)
          切り捨て関数(負の無限方向への切り捨て)
     float(X)
          整数の浮動小数点数への変換X は整数式で、結果は浮動小数点数に変
          換します(*Note 整数演算: Integer Arith.)。
     +X
          X が結果となります。
     -X
          符号の反転

     この述語は、節のガードとボディの両方で利用可能です。

     式中に、具体化されていないオペランドがある場合、すべてのオペランド
     が具体化されるまで計算は中断します。

     式中のいくつかのオペランドに対して、再帰的な式を指定できます。ただ
     し、プログラム中で変数として書くオペランドは、`3.0 + 5.0' のような
     合成項に具体化しては *なりません*。具体化するのは浮動小数点数だけに
     してください。浮動小数点数以外に具体化すると、型不一致のエラーが発
     生します。

上記の演算は、浮動小数点数のジェネリック・メソッドとしても提供しています。

 -- ボディ・メソッド on float: add +X +Y -R
 -- ボディ・メソッド on float: subtract +X +Y -R
 -- ボディ・メソッド on float: multiply +X +Y -R
 -- ボディ・メソッド on float: divide +X +Y -R
 -- ボディ・メソッド on float: pow +X +Y -R
 -- ボディ・メソッド on float: sin +X -R
 -- ボディ・メソッド on float: cos +X -R
 -- ボディ・メソッド on float: tan +X -R
 -- ボディ・メソッド on float: asin +X -R
 -- ボディ・メソッド on float: acos +X -R
 -- ボディ・メソッド on float: atan +X -R
 -- ボディ・メソッド on float: sinh +X -R
 -- ボディ・メソッド on float: cosn +X -R
 -- ボディ・メソッド on float: tanh +X -R
 -- ボディ・メソッド on float: exp +X -R
 -- ボディ・メソッド on float: log +X -R
 -- ボディ・メソッド on float: sqrt +X -R
 -- ボディ・メソッド on float: ceil +X -R
 -- ボディ・メソッド on float: floor +X -R
     これらのメソッドは、メソッド名で規定した算術演算を実行します。オペ
     ランドを指定すると、その結果を R へ返します。



File: KLICj.info, Node: Floating Comp, Prev: Floating Arith, Up: Floating Points

浮動小数点比較
..............

浮動小数点データの比較は、ここで説明する述語を用いて行えます。より一般的
な比較述語も提供しています(*Note 比較とハッシュ: Comparison and
Hashing.)。ただし、ここで説明する述語とメソッドは、オペランドが浮動小数
点数であることが明らかな場合に使用すると、より効率的です。

 -- ガード述語 on builtin: $> +X +Y
 -- ガード述語 on builtin: $>= +X +Y
 -- ガード述語 on builtin: $=:= +X +Y
 -- ガード述語 on builtin: $=\= +X +Y
 -- ガード述語 on builtin: $=< +X +Y
 -- ガード述語 on builtin: $< +X +Y

     これらの述語は、2 つの浮動小数点引数の比較演算を行います。値の同値
     関係のチェックには(浮動小数点数の場合は、たいして意味のあることでは
     ありませんが)、 `=:=' と `=\=' を使用してください。比較の両側には浮
     動小数点式を指定できます。
      `$:=' で用いたものと同じ演算子群が使えます。

     *バグに注意*` '
     現在の版 (2.001) では、これらの述語に対して演算子付き式の使用は避け
     てください。単純な変数と定数だけを使用してください。

浮動小数点数の比較は、次のメソッドでも行えます。

 -- ガード・メソッド on float: less_than +X +Y
 -- ガード・メソッド on float: not_greater_than +X +Y
 -- ガード・メソッド on float: not_less_than +X +Y
 -- ガード・メソッド on float: greater_than +X +Y
 -- ガード・メソッド on float: equal +X +Y
 -- ガード・メソッド on float: not_equal +X +Y

     これらの方法では、X が Y より小さいか否か等をテストします。



File: KLICj.info, Node: Structured Data, Next: Executable Code, Prev: Atomic Data, Up: Builtin and Library

構造型データ
============

構造型データ・オブジェクトは、0 個以上の要素で構成します。

* Menu:

* Functors::                    ファンクタ構造
* Lists::                       リスト
* Vectors::                     ベクタ
* Strings::                     文字列
character codes



File: KLICj.info, Node: Functors, Next: Lists, Prev: Structured Data, Up: Structured Data

ファンクタ構造
--------------

ファンクタ構造は、与えられた名前と 1 個以上の任意の型の要素を持つ構造で
す。ファンクタは、あらかじめ大きさが分かっているデータ構造を表すのに向い
ています。ファンクタは、C 風言語のレコード構造に対応します。

* Menu:

* Notation of Functors::        ファンクタの表記
* Functor Operation::           ファンクタの操作



File: KLICj.info, Node: Notation of Functors, Next: functor Operation, Prev: Functors, Up: Functors

ファンクタの表記
................

ファンクタ定数は、主ファンクタ名、左括弧、コンマで区切られた要素、および
最後の右括弧で書くことができます。ファンクタ名は記号アトムと同じ構文です。
主ファンクタ名とそれに続く左括弧を、空白文字や区切り記号等で分けては*な
りません*。要素には、変数やファンクタ自身を含む任意の型が指定できます。

例 :
     f(a, 3)   'a recursive functor structure'(X, 'child functor'(Y))



File: KLICj.info, Node: Functor Operation, Prev: Notation of Functors, Up: Functors

ファンクタの操作
................

ファンクタ構造を操作する述語は、以下に示すように組込み述語として提供した
り、`functor_table' モジュール中に提供したりしています。

現在の実装では、次に示すボディ組込み述語のすべてが、`functor_table' モジュー
ルの述語に展開したマクロ形式で実装しています。この実装方法は、将来のリリー
スで変更する可能性があります。

 -- ガード述語 on builtin: functor +X -FUNCTOR -ARITY
 -- ボディ述語 on builtin: functor +X -FUNCTOR -ARITY
      X は、主ファンクタ名が FUNCTOR で、引数個数が ARITY のファンクタで
     す。上記の述語は、主ファンクタ名とその引数個数、またはそれらのどち
     らか一方を得るために使用します。ガード述語として呼び出された場合に
     は、X が名前 FUNCTOR と引数個数 ARITY を持つこと、またはそれらのど
     ちらか一方を持つこと、のテストにも使用できます。アトム・データ、文
     字列、ベクタなどの、ファンクタ構造でない具体化データは、引数個数が 
     0 となり、自分自身が主ファンクタ名になります。リスト構造は、ファン
     クタ `./2' で構成しているので注意してください。

     この述語では、新しいファンクタは生成できません。

 -- ガード述語 on builtin: arg +POS +TERM -ARG
 -- ボディ述語 on builtin: arg +POS +TERM -ARG
      TERM の POS 番目の引数は ARG です。引数は 1 から番号付けしています。
     ガード述語として呼び出された場合、 POS が範囲外なら単に失敗するだけ
     です。この述語をファンクタ構造以外のデータ構造に使用すると、それら
     のデータ構造は引数を持たないので、常に失敗します。

 -- ボディ述語 on builtin: new_functor -FUNCTOR +ATOM +ARITY
     主ファンクタ名が ATOM で引数個数が ARITY のファンクタ構造を、 
     FUNCTOR へ返します。生成したファンクタの引数は、整数 `0' で初期化し
     ています。

 -- ボディ述語 on builtin: setarg +POS +FNCT ?NEWE -NEWFNCT
 -- ボディ述語 on builtin: setarg +POS +FNCT ?OLDE ?NEWE -NEWFNCT
     POS番目の引数だけが FNCT と異なる新しいファンクタ構造を生成して、 
     NEWFNCT へ返します。 NEWFNCT の POS 番目の要素は NEWEになります。
      5 個の引数を持つ述語の場合、FNCT の POS 番目の引数を、 OLDE へ返し
     ます。

 -- functor_table on 述語: =.. -NEWFNCT +LIST
     新しいファンクタを生成して、NEWFNCT へ返します。主ファンクタ名は、
     LIST の最初の要素に記号アトムで指定しなければなりません。引数は、
     LIST の残りの部分に指定します。LIST の要素が 1 個だけの場合、その要
     素を NEWFNCT へ返します。

     この述語は、ファンクタ構造をリストに分解するためには使え*ません*。



File: KLICj.info, Node: Lists, Next: Vectors, Prev: Functors, Up: Structured Data

リスト
------

リストは、任意の長さのデータ・オブジェクトの並びです。KL1 では、リスト構
造は、名前 `.' と 2 個の引数を持つファンクタ構造、 `./2' で構成します。
リスト構造は、これら`コンス・セル'とも呼ばれるファンクタ構造で構成します。

コンス・セルの 1 番目の要素は、時にはセルの "car" とも呼ばれますが、リス
トの 1 番目の要素を表します。セルの "cdr" である 2番目の要素は、リストの
残りの部分を表します。リストの終端は、その cdr が記号アトム `[]' である
ことで示します。

与えられた引数がリストか否かは、次のガード述語でテストできます。

 -- ガード述語 on builtin: list +X
     X がコンス・セルか否かをテストします。この述語は、X が空リスト `[]' 
     であると、X の名前とは関係なく、失敗するので注意してください。

徐々に具体化されるリスト構造は、メッセージ・ストリームとして使用すると便
利です。

* Menu:

* Notation of Lists::           リストの表記
* Merging::                     メッセージストリームの操作



File: KLICj.info, Node: Notation of Lists, Next: Merging, Prev: Lists, Up: Lists

リストの表記
............

KL1 のリストは、Lisp のように*コンス*のデータ構造を用いて構築します。コ
ンスのデータ構造は、実際にはファンクタ構造 `./2' です。

リストの基本的な表記は、`[CAR|CDR]' です。すなわち、リストの最初の要素が 
CAR で、末尾が CDR で構成します。これは、`.(CAR, CDR)' とまったく同じ意
味になります。空リストは、アトム `[]' で表します。

CDR が空の場合、つまり、リストが 1 個の要素 CAR だけで構成する場合、リス
トは `.(CAR, [])' 、または `[CAR|[]]' と表記します。後者の場合、 リスト
の末尾の `|[]' は省略できるので、 `[CAR]' と書くこともできます。つまり、
car が CAR で、cdr が `[CADR, ...]' であるリストは、`[CAR|[CADR, ...]]' 
と書けます。これは、`[CAR, CADR, ...]' のように省略形でも書けます。例え
ば、4個の要素、`first'、`second'、`third'、`fourth' からなるリストは、
`[first, second, third, fourth]' と書けます。

4個以上の要素からなるリストで、最初の 4個の要素が `first'、`second'、
`third'、`fourth' の場合、`[first, second, third, fourth | Rest]' と書け
ます。ここで、変数 `Rest' は、5番目の要素で始まるリストに対応します。リ
スト全体が 4個の要素だけの場合には、`Rest' は空リストに対応します。

Edinburgh Prolog とは異なり、文字の並びの`,..'は `|'の代わりには使用でき
ないので注意してください。



File: KLICj.info, Node: Merging, Prev: Notation of Lists, Up: Lists

メッセージ・ストリームの操作
............................

ストリーム・マージャは、メッセージのリストとして表現される複数のメッセー
ジ・ストリームを入力として受け取り、それらすべての入力ストリームのメッセー
ジを、リストとして表現する単一の出力ストリームに渡すプロセスです。

出力は、入力中のすべてのメッセージを複製したものから成り立ちます。2 つの
メッセージに対して、どれか 1 つの入力ストリームで順序付けを行うと、それ
らのメッセージの順序は出力中でも変わることはありません。出力中のメッセー
ジが複数の入力ストリームから渡される場合、メッセージの出力順序は予測でき
ません。その出力順序は、同じプログラムでも実行ごとに異なる可能性がありま
す。このように、マージャは非決定的な動作をします。

例えば、2つの入力ストリーム、`[1, 2, 3]' と `[a, b, c]' が存在する場合、
出力は、`[1, 2, a, b, 3, c]' や `[1, a, 2, b, c, 3]' にはなりますが、決
して `[1, a, 3, b, c, 2]' になることはありません。

KL1 では、2 入力のストリーム・マージャを、次のように定義できます。

     merge([M|In1], In2, Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge(In1, [M|In2], Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge([], In2, Out) :- Out=In2.
     merge(In1, [], Out) :- Out=In1.

   * 上記のマージャの定義において、
      1 番目の節（clause）は、最初の入力ストリームから、1 つのメッセージ
     を出力ストリームに転送します。最初の入力ストリームは最初の引数であ
     り、出力ストリームは述語の 3番目の引数です。続いて、繰返し実行のた
     めに再帰的に述語 `merge/3' を呼び出します。

   * 2 番目の節は、2番目の入力ストリームに対して、同じ処理を行います。

   * 3 番目の節は、最初の入力ストリーム中にメッセージが存在しない場合に
     使用します。この場合、2番目の入力ストリームを直接、出力に接続します。
     最初の入力ストリームから転送するメッセージはないので、マージの結果
     は 2番目の入力ストリームと同じになります。

   * 4 番目の節は、2番目の入力ストリーム中にメッセージが存在しない場合に
     使用します。

メッセージを同時に両方の入力ストリームから受け取る場合、1 番目か 2 番目
のどちらか一方の節が任意に選ばれます。このことがマージャの非決定性の原因
です。

2 入力のマージャは、KL1 では容易に定義できますが、任意の多入力ストリーム
のマージャを定義することは、容易ではありません。新しい入力ストリームを動
的に追加することも望まれますが、さらに難しくなります。また、マージャは 
KL1 プログラムで非常によく使用されるので、効率的である必要があります。し
たがって、KLIC システムでは、マージャを標準的な機能として提供します。

新しいマージャは、以下に示す疑似述語によって生成します。

 -- オブジェクト生成 on merge: new ?INPUT ?OUTPUT
     単一の入力ストリームを持つ新しいマージャを生成します。入力ストリー
     ムは INPUT で、出力ストリームは OUTPUT になります。

上記の疑似述語で生成したマージャ・プロセスは、実際には、生成直後はマージ
を開始しません。単に INPUT からのメッセージを OUTPUT に、順序を変えずに
転送するだけです。

新しい入力ストリームをマージャに追加するには、入力をベクタで単一化してく
ださい。そのベクタの要素が新たな入力ストリームになります。例えば、バイナ
リのマージャが必要な場合、次のようにしてください。

     generic:new(merge, INPUT, OUTPUT),
     INPUT = {IN1, IN2}

これは、次の処理と同じ意味になります。

     generic:new(merge, {IN1, IN2}, OUTPUT)

上記処理後、マージャは 2 個の入力ストリーム IN1 と IN2 からのメッセージ
を、出力ストリーム OUTPUT へマージします。

マージャへの入力ストリームの追加は、生成直後だけでなく、要求に応じて任意
に行えます。例えば、2 個以上の入力ストリームを追加する例を、次に示します。

     IN2 = {IN2A, IN2B, IN2C}

この結果、マージャは 4 個の入力ストリーム IN1、IN2A、IN2B、IN2Cを持つこ
とになります。

入力ストリームの 1 つが必要なくなった場合、その入力ストリームをアトム 
`[]' で単一化するだけで、簡単に閉じることができます。

入力ストリームに単一化されるベクタのサイズは、任意に変更できます。ベクタ
が 1 個の要素しか持っていない場合、入力ストリームの数は変更されません。
ベクタが要素を持っていない場合、ベクタを単一化すると、ストリームを閉じる
ことになります。

すべての入力ストリームを閉じたとき、出力リストの末尾を `[]'と単一化する
ので、出力ストリームも閉じます。

マージャを使用する際のヒントを、次に示します。

   * マージするメッセージには、未束縛変数を含むデータ構造を許します。そ
     のようなメッセージは、"不完全メッセージ" とも呼びます。不完全メッセー
     ジは、クライアント/サーバのプロセス構造を構築する場合に向いています。
     メッセージ中の変数に値を与えると、サーバからクライアントへの返信に
     使用できます。

   * 逐次実装におけるマージは、決定的に見えるかも知れません。しかし、並
     列実装におけるマージは、非決定的になりますので、決して頼らないでく
     ださい。



File: KLICj.info, Node: Vectors, Next: Strings, Prev: Lists, Up: Structured Data

ベクタ
------

ベクタは、固定長の 1 次元配列の KL1 データです。ベクタの長さは、生成の際
に決定します。要素には、任意の KL1 データを許し、データ構造を生成した時
点で、未定義の状態でいることも許します。

要素は 0 から始まる整数によって、インデックス付けします。例えば、3 個の
要素を持つベクタは、0、1、2 と番号が付いた要素になります。

* Menu:

* Notation of Vectors::         ベクタの表記
* Creating Vectors::            ベクタの生成
* Predicates on Vectors::       ベクタの述語



File: KLICj.info, Node: Notation of Vectors, Next: Creating Vectors, Prev: Vectors, Up: Vectors

ベクタの表記
............

ベクタは、1 対の中括弧 (`{}') の中で、要素の並びをコンマで区切ることで表
します。

     { 1, a, f(b), X }

空ベクタ(要素のないベクタ)は 1 対の中括弧だけで表します。

     {}

中括弧は、Edinburgh Prolog とは完全に異なった意味で使用するので、注意し
てください。Edinburgh Prolog では、`{}'はアトムを意味し、`{...}' はファ
ンクタ構造 `{}((...))'を意味します。



File: KLICj.info, Node: Creating Vectors, Next: Predicates on Vectors, Prev: Notation of Vectors, Up: Vectors

ベクタの生成
............

前項で示した表記に加えて、ベクタをプログラムの実行中に動的に生成できます。
次に示す述語は、新しいベクタを生成するために使えます。

 -- オブジェクト生成 on vector: new -VECTOR +INIT
 -- ボディ述語 on builtin: new_vector -VECTOR +INIT
     新しいベクタを生成して、VECTOR へ返します。

     引数 INIT が整数の場合、要素数を指定したことになります。この場合、
     要素を整数 `0' で初期化します。例えば、`generic: new(vector, V, 2)' 
     はベクタ `{0, 0}' を生成して、`V' へ単一化します。

     引数 INIT がリストの場合、新しく生成したベクタを、リストの要素によっ
     て初期化します。当然、ベクタの要素数はリストの長さと同じになります。
     例えば、`generic:new(vector, V, [a, b, c])' は ベクタ `{a, b, c }'
     を生成して、`V' へ単一化します。



File: KLICj.info, Node: Predicates on Vectors, Prev: Creating Vectors, Up: Vectors

ベクタの述語
............

 -- ガード・メソッド on vector: vector +VECTOR -LENGTH
 -- ボディ・メソッド on vector: size +VECTOR -LENGTH
 -- ガード述語 on builtin: vector +VECTOR -LENGTH
     (ガード述語で呼び出された場合、)VECTOR がベクタ・オブジェクトか否か
     をテストします。要素数を LENGTH へ返します。

 -- ガード・メソッド on vector: element +VECTOR +INDEX -ELEMENT
 -- ボディ・メソッド on vector: element +VECTOR +INDEX -ELEMENT
 -- ガード述語 on builtin: vector_element +VECTOR +INDEX -ELEMENT
 -- ボディ述語 on builtin: vector_element +VECTOR +INDEX -ELEMENT
     ベクタ VECTOR の INDEX 番目の要素を、ELEMENTと単一化します。インデッ
     クスは、ゼロから始まります。

 -- ボディ・メソッド on vector: set_element +ORIGINAL +INDEX ?NEWELEMENT -NEW
 -- ボディ述語 on builtin: set_vector_element +ORIGINAL +INDEX ?NEWELEMENT -NEW
     新しいベクタを NEW と単一化します。
      INDEX 番目の要素を更新して、NEWELEMENT にする他は、 ORIGINAL と同
     じ要素になります。オリジナルのベクタには影響しません。インデックス
     は、ゼロから始まります。

 -- ボディ・メソッド on vector: set_element +ORIGINAL +INDEX ?ELEMENT ?NEWELEMENT -NEW
 -- ボディ述語 on builtin: set_vector_element +ORIGINAL +INDEX ?ELEMENT ?NEWELEMENT -NEW
     新しいベクタを NEW と単一化します。
      INDEX 番目の要素を更新して、 NEWELEMENT にする他は、 ORIGINAL と同
     じ要素になります。オリジナルのベクタには影響しません。インデックス
     は、ゼロから始まります。
      INDEX 番目のオリジナルの要素を ELEMENT へ返します。

 -- ボディ・メソッド on vector: split +ORIGINAL +AT -LOWER -UPPER
     ベクタ ORIGINAL を AT 番目で分割し、2 つのベクタを LOWER と UPPER 
     に単一化します。AT は、オリジナルのベクタのサイズ以下で、かつゼロ以
     上の整数です。LOWER は、0番目以上 `AT-1'番目以下の要素で構成します。
     UPPER は、AT 番目以上の要素で構成します。

 -- ボディ・メソッド on vector: join +LOWER +UPPER -JOINED
     LOWER と UPPER の 2 つのベクタを結合して、新しいベクタ JOINED にし
     ます。

KLIC では、既存のベクタと 1 要素だけが異なる新たなベクタの生成は、ベクタ
のサイズとは関係なく、時間と領域がともに一定のオーバヘッドで済むマルチバー
ジョン配列表現を用いて実装しています。



File: KLICj.info, Node: Strings, Prev: Vectors, Up: Structured Data

文字列
------

文字列は、限定された範囲の整数の 1 次元配列です。現在の版では、0 〜 255 
個の要素を持つ 8 ビット要素の文字列だけを提供しています。それらは、文字
の列を表す場合に向いています。異なるサイズの要素からなる文字列を、将来計
画しています。

Edinburgh Prolog とは異なり、文字列は、文字コードのリスト用の表記規約で
は*ありません*。文字列は、それ自身のデータ型を持ちます。

* Menu:

* Notation of Strings::         文字列の表記
* Creating Strings::            文字列の生成
* Predicates on Strings::       文字列の述語



File: KLICj.info, Node: Notation of Strings, Next: Creating Strings, Prev: Strings, Up: Strings

文字列の表記
............

文字列定数は次のように、 1 対の二重引用符(")で囲まれた文字の並びで表しま
す。

     "A string of the characters written here"

次のエスケープ・シーケンスは、(ANSI C のように)二重引用符、バックスラッ
シュ、制御コードなどを文字列の要素として指定するために使います。

`\a'
     ビープ音
`\b'
     バックスペース
`\t'
     タブ
`\n'
     改行
`\v'
     垂直タブ
`\f'
     改ページ
`\r'
     復帰
`\''
     単一引用符
`\"'
     二重引用符
`\?'
     疑問符
`\\'
     バックスラッシュ　
      2 個の連続するバックスラッシュで文字列中の 1 個のバックスラッシュ
     を指定する
`\ooo'
      8 進数 ooo で指定するコード最大 3 桁の 8 進数が指定できる
`\xhh'
      16 進数 hh で指定するコード任意桁の 16 進数が指定できる
`\NEWLINE'
     直後に改行コードの付いたバックスラッシュを無視する文字列中では、こ
     の並びには文字が無くなる

例:

     "The character \'\"\' (doublequote)"

上記の例では、次の文字を含む文字列として解釈します。

     The character '"' (doublequote)

文字列には、改行や二重引用符を直接含んではなりません。文字列内に改行を含
む標準的な方法は、行を `\n\' で終了させることです。この方法では、改行コー
ドを、`\n' で挿入し、2 番目の `\'に続くソース・コード中の実際の改行を、
無視します。

Edinburgh Prolog とは異なり、文字列は文字コードのリストでは*ありません*。



File: KLICj.info, Node: Creating Strings, Next: Predicates on Strings, Prev: Notation of Strings, Up: Strings

文字列の生成
............

上記の文字列定数に加えて、文字列を実行中に動的に生成できます。次の述語が
新しい文字列を生成するために使えます。

 -- オブジェクト生成 on string: new -STRING +INIT +ELEMSIZE
 -- ボディ述語 on builtin: new_string -STRING +INIT +ELEMSIZE
     新しい文字列を生成して、STRING と単一化します。最後の引数 ELEMSIZE 
     には要素のビット幅を指定します。現在の版では、8 ビット文字列しか利
     用できないので、これは 8 になります。

     引数 INIT が整数の場合、要素数が指定されたことになります。この場合、
     要素を整数 `0'(ヌル・コード)で初期化します。例えば、
     `generic:new(string, S, 3, 8)' は `"\0\0\0"' を生成します。

     引数 INIT が整数のリストの場合、新しく生成された文字列を、リストの
     要素によって初期化します。当然、文字列の要素数はリストの長さと同じ
     になります。この場合、リストの要素は、与えられたビット幅に適合する
     値、つまり 8 ビット文字列で構成する場合、0 〜 255 の値になります。
     例えば、`generic:new(string, S, [0'a, 0'b, 0'c], 8)' は `"abc"' を
     生成します。



File: KLICj.info, Node: Predicates on Strings, Prev: Creating Strings, Up: Strings

文字列の述語
............

 -- ガード・メソッド on string: string +STRING -LENGTH -ELEMSIZE
 -- ボディ・メソッド on string: string +STRING -LENGTH -ELEMSIZE
 -- ガード述語 on builtin: string +STRING -LENGTH -ELEMSIZE
     (ガード述語で呼び出された場合)、STRING が文字列オブジェクトか否かを
     テストします。STRING の要素数を LENGTH へ、要素サイズ(現在の版では
     常に8)を ELEMSIZE へ返します。

 -- ボディ・メソッド on string: size +STRING -LENGTH
     STRING の要素数を LENGTH へ返します。

 -- ボディ・メソッド on string: element_size +STRING -ELEMSIZE
     STRING の要素サイズを ELEMSIZE へ返します。

 -- ガード・メソッド on string: element +STRING +INDEX -ELEMENT
 -- ボディ・メソッド on string: element +STRING +INDEX -ELEMENT
 -- ガード述語 on builtin: string_element +STRING +INDEX -ELEMENT
 -- ボディ述語 on builtin: string_element +STRING +INDEX -ELEMENT
     文字列 STRING の INDEX 番目の要素を ELEMENT と単一化します。インデッ
     クスは、ゼロから始まります。

 -- ガード・メソッド on string: less_than +STRING1 +STRING2
 -- ガード述語 on builtin: string_less_than +STRING1 +STRING2
     辞書式順序で、STRING1 がSTRING2 より小さい場合だけ成功します。

 -- ガード・メソッド on string: not_less_than +STRING1 +STRING2
 -- ガード述語 on builtin: string_not_less_than +STRING1 +STRING2
     辞書式順序で、STRING1 が STRING2 以上の場合だけ成功します。

 -- ガード・メソッド on string: string +STRING -LENGTH -ELEMSIZE
 -- ガード述語 on builtin: string +STRING -LENGTH -ELEMSIZE
     STRING の要素数を LENGTH へ返し、要素サイズ(常に8)を ELEMSIZEへ返し
     ます。

 -- ボディ・メソッド on string: set_element +ORIGINAL +INDEX ?ELEMENT +NEW
 -- ボディ述語 on builtin: set_string_element +ORIGINAL +INDEX ?ELEMENT +NEW
     新しい文字列を NEW で単一化します。新しい文字列の、INDEX 番目の要素
     を更新して、 ELEMENT にする他は、ORIGINAL と同じ要素になります。オ
     リジナルの文字列には影響しません。インデックスは、ゼロから始まりま
     す。

 -- ボディ・メソッド on string: split +ORIGINAL +AT -LOWER -UPPER
     文字列 ORIGINAL を、 AT 番目で分割し、 2 個の文字列を LOWER と 
     UPPER に単一化します。AT は、オリジナルの文字列のサイズ以下で、かつ
     ゼロ以上の整数です。LOWER は、0 番目以上 `AT-1' 番目以下の要素で構
     成します。UPPER は、AT 番目以上の要素で構成します。

 -- ボディ・メソッド on string: join +LOWER +UPPER -JOINED
     LOWER と UPPER の 2 つの文字列を結合して、新しい文字列 JOINED にし
     ます。

 -- ボディ・メソッド on string: search_character +STRING +START +END +CHAR -WHERE
 -- ボディ述語 on builtin: search_character +STRING +START +END +CHAR -WHERE
     文字 CHAR を STRING 中で探索します。探索は、位置 START から開始し、
     END の前で終わります。探索する文字が見つかった場合、そのインデック
     スを、WHERE と単一化します。見つからなかった場合、WHERE を `-1' と
     単一化します。インデックスは、ゼロから始まります。

KLIC では、既存の文字列と 1 要素だけが異なる新たな文字列の生成は、文字列
のサイズとは関係なく、時間と領域がともに一定のオーバヘッドで済むマルチバー
ジョン配列表現を用いて実装しています。




File: KLICj.info, Node: Executable Code, Next: Unix, Prev: Structured Data, Up: Builtin and Library

プログラム・コードのデータとしての扱い
======================================

KLIC では、データ・オブジェクトとして、実行コードの高次な操作が可能です。
プログラム・モジュールは、"モジュール"・データ・オブジェクトとして扱い、
個々の述語は、"述語"データ・オブジェクトとして扱います。

* Menu:

* Module Type::                 モジュール
* Predicate Type::              述語



File: KLICj.info, Node: Module Type, Next: Predicate Type, Prev: Executable Code, Up: Executable Code

モジュール
----------

プログラム・モジュールは、`module' 型のジェネリック・データ・オブジェク
トによってデータとして扱います。

 -- オブジェクト生成 on module: new -MODULE +MODULENAME
     記号アトムの MODULENAME で指定されたプログラム・モジュールに対応する、新しいオブジェクト MODULE を生成します。
     指定されたモジュールが定義されていない場合、記号アトム自身を MODULE へ返します。
     オブジェクト生成ゴールのフォーマットについては、
     *Note ジェネリック・オブジェクトの生成: Creating Objects。

 -- ガード・メソッド on module: module +MODULE
     MODULE がモジュール・オブジェクトか否かをテストします。


 -- ボディ・メソッド on module: name +MODULE -MODULENAME
     MODULE のモジュール名を、記号アトムとして MODULENAME へ返します。



File: KLICj.info, Node: Predicate Type, Prev: Module Type, Up: Executable Code

述語
----

プログラムの述語は、述語(`predicate') 型のジェネリック・データ・オブジェ
クトによってデータとして扱います。

述語型データは、定数として表わすか、実行時に動的に生成するかのどちらかで
す。ホスト・システムの機能の制約のため、ホスト・システムによっては、動的
な生成をサポートしない場合があります。

述語定数の構文は次のとおりです。

     `predicate'`#'`('MODULE`:'PREDICATE`/'ARITY`)'

ここで、MODULE と PREDICATE がモジュールと述語の名前アトムであり、ARITY 
が整数(述語の引数個数)になります。例えば、

     predicate#(main:main/0)  predicate#(quicksort:partition/4)

これらは、プログラムで有効な述語定数です。

述語定数は、KLIC のパーサでなく、KLIC のコンパイラが認識するので注意して
ください(*Note Prolog 風のインタフェースを用いた入出力: Prolog I/O.)。し
たがって、Prolog 風の I/O ストリームを用いて単に読み込むだけの場合、上記
の表記は、通常のデータ構造を意味します。

 -- オブジェクト生成 on predicate: new -PREDICATE +MODULE +PREDNAME +ARITY
     MODULE(モジュール・オブジェクト)、PREDNAME(記号アトム)、
     ARITY(整数)で指定する述語に対応する
     新しいオブジェクト PREDICATE を生成します。
     オブジェクト生成ゴールのフォーマットについては、
     *Note ジェネリック・オブジェクトの生成: Creating Objects。

 -- ガード・メソッド on predicate: predicate +PREDICATE
     PREDICATE が述語オブジェクトか否かをテストします。

 -- ガード・メソッド on predicate: arity +PREDICATE -ARITY
 -- ボディ・メソッド on predicate: arity +PREDICATE -ARITY
     述語PREDICATE の引数個数を ARITY へ返します。

 -- ボディ・メソッド on predicate: apply +PREDICATE +ARGVEC
     述語オブジェクトの PREDICATE で指定した述語を ARGVEC で指定した引数
     で呼び出します。ARGVEC は、PREDICATE に渡す引数のベクタです。したがっ
     て、ベクタのサイズは、述語の引数個数と一致させる必要があります。

 -- ボディ・メソッド on predicate: call +PREDICATE +ARGS...
     述語オブジェクトの PREDICATE で指定した述語を `ARGS...' で指定した
     引数で呼び出します。引数の数は、述語の引数個数と一致させる必要があ
     ります。

 -- ボディ・メソッド on predicate: module +PREDICATE -MODULE
     PREDICATE が属するプログラム・モジュールを、モジュール・データ・オ
     ブジェクトとして MODULE へ返します。

 -- ボディ・メソッド on predicate: name +PREDICATE -NAME
     述語 PREDICATE の名前を、記号アトムとして NAME へ返します。



File: KLICj.info, Node: Unix, Next: Input and Output, Prev: Executable Code, Up: Builtin and Library

Unix インタフェース
===================

`unix' という名前のモジュールによって、ホスト・オペレーティング・システ
ム(代表例として `Unix')の機能を KL1 プログラムから利用できるようになりま
す。

機能のほとんどは、 `unix' モジュールが提供する述語 `unix/1' で獲得したス
トリームに対するメッセージとして利用可能です。いくつかの機能は、述語とし
て提供しています。

* Menu:

* Unix Stream::                 Unix インタフェース・ストリームの獲得
* I/O Opening::                 入出力用ストリームのオープン
* Sockets::                     ソケットの使い方
* Files & Dirs::                ファイルとディレクトリ
* Signals::                     シグナル割込みの処理
* Misc Unix Messages::          Unix ストリームへのシュシュのメッセージ
* Predicate Interface::         述語インタフェース



File: KLICj.info, Node: Unix Stream, Next: I/O Opening, Prev: Unix, Up: Unix

Unix インタフェース・ストリームの獲得
-------------------------------------

ユーザは、unix モジュールをメッセージ・ストリームを介して利用します。そ
のストリームは、次の述語を呼び出すことによって得られます。

 -- predicate on unix: unix ?STREAM
     Unix インタフェースに対応するメッセージ・ストリームを STREAM へ返し
     ます。

述語の呼出し順序は、保証できないため、Unix インタフェース機能のほとんど
は、述語として提供*しません*。仮に、Unix インタフェースが述語として提供
されるとしたら、次に示す例の `ls' の結果は、実行順序に依存することになり
ます。
     unix:cd("a", 0),
     unix:cd("b", 0),
     unix:system("ls", 0)

つまり、実行順序によっては、ディレクトリ `a' を表示したり、 `b' を表示し
たり、または、2 つの `cd' を実行する前にどこかのディレクトリを表示したり
するかもしれません。一方、次に示す例の場合は、実行順序によってではなく、
リスト中に並んだ要素の順序に従って、2 つの `cd' と、`ls' を実行します。

     unix:unix([cd("a", 0),
                cd("b", 0),
                system("ls", 0)])

@noindent

並列実装では、KLIC は複数プロセスを構成します。すべてのメッセージは、
unix ストリームを獲得するプロセスで処理します。例えば、`cd(Path)' メッセー
ジは、単一プロセスのワーク・ディレクトリと、他に何も存在しないワーク・ディ
レクトリを変更します。

複数のメッセージ・ストリームを獲得した場合、異なるストリームへ送られたメッ
セージ間の同期はとりません。



File: KLICj.info, Node: I/O Opening, Next: Sockets, Prev: Unix Stream, Up: Unix

入出力用ストリームのオープン
----------------------------

Unix ストリームに、次のメッセージを送って、Unix I/O ストリームをオープンします。
入出力を実行するために(Unix ストリーム自身ではなく) Unix I/O ストリームに
送るメッセージについては、別の場所で説明します
(*Note C 風のインタフェースを用いた入出力: C-like I/O,
*Note Prolog 風のインタフェースを用いた入出力: Prolog I/O)。

次に示す例は、「hello world」と出力する KLIC プログラムです。

     main :- unix:unix([stdout(R)]), check_and_write(R).

     check_and_write(normal(R)) :- R = [fwrite("hello world\n")].

 -- メッセージ on unix ストリーム: stdin -RESULT
 -- メッセージ on unix ストリーム: stdout -RESULT
 -- メッセージ on unix ストリーム: stderr -RESULT

     これらのメッセージによって、プロセスの標準入力、標準出力、および標
     準エラー・ファイルと関連する個々のストリームをオープンし、RESULT へ
     `normal(STRING)'を返します。

 -- メッセージ on unix ストリーム: read_open +PATH -RESULT
 -- メッセージ on unix ストリーム: write_open +PATH -RESULT
 -- メッセージ on unix ストリーム: append_open +PATH -RESULT
 -- メッセージ on unix ストリーム: update_open +PATH -RESULT
     これらのメッセージによって、文字列の PATH に指定したファイルをオー
     プンし、RESULT へ `normal(STRING)'を返します。オープン・モードは、
     入力、出力、追加、および入力/出力の各モードです。ファイルのオープン
     に失敗した場合、 `abnormal' を返します。



File: KLICj.info, Node: Sockets, Next: Files & Dirs, Prev: I/O Opening, Up: Unix

ソケットの使い方
----------------

Unix ストリームに以下のメッセージを送って、Unix とインターネットのプロト
コルのソケットを獲得します。SOCK_STREAM 型のソケットだけを提供しています。

 -- メッセージ on unix ストリーム: connect +SPEC -RESULT
     ソケットを生成し、Spec で指定されたソケット・アドレスと接続し、
     RESULT へ `normal(STRING) 'を返します。SPECは、以下に示す形式のいず
     れかです。

     unix(PATH)
          パス名 PATH を持つ Unix ドメインのソケットをオープンします。
     inet(HOSTNAME, PORT)
          ホスト名 HOSTNAME とポート番号 PORT で指定したホストのインター
          ネット・ドメインのソケットをオープンします。
     inet({B1, B2, B3, B4}, PORT)
          インターネット・ドメインのソケットをオープンし、インターネット・
          アドレスの B1 から B4 で指定したホストをオープンします。獲得し
     たストリームで、入力と出力の両方のメッセージを処理します。

 -- メッセージ on unix ストリーム: bind +SPEC -RESULT
     ソケットを生成し、SPEC で指定したソケット・アドレスへバインドします。
     SPEC の形式は、インターネット・ドメインのソケットに対する HOSTNAME 
     を省略している他は、 `connect' の場合と同じです。`normal(STREAM)' 
     を RESULT へ返します。この STREAM はバインドされたソケット・ストリー
     ムであるため、直接 I/O メッセージを処理しません。I/O メッセージ・ス
     トリームを得るためには、さらに `accept' メッセージを使用します。ソ
     ケットが `unix' ドメインの場合、バインドされたソケット・ストリーム
     を閉じ、SPEC 中の PATH で指定された名前付きソケットをアンリンクしま
     す。

 -- メッセージ on バウンド・ソケット: accept -RESULT
     ソケットへの接続を受け入れ、RESULT へ `normal(STREAM)' を返します。
     ここで、STREAM は入力と出力の両メッセージ用のI/O メッセージ・ストリー
     ムです。

ソケットは、非同期 I/O を提供します。すなわち、KLIC システムでは、接続待
ちや接続の受け入れ時に他のプロセスを中断することはありません。ソケットに
対して、空のバッファから読み込んだり、満杯のバッファに書き出したりしても
全体の演算実行は中断しません。そのような入出力操作は、操作が可能になるま
で延期します。

*制限事項*:
ソケットへの操作を延期した場合、ソケットに対する残りの操作のすべても、延
期した操作が完了するまで延期します。このことは、入力と出力の双方をポーリ
ングする必要がある場合に問題です。この問題は、将来のリリースで解決する予
定です。

*Linux に関する制限事項*:
現在の版では、非同期 I/O は(少なくとも Slackware 1.2.0 の)Linuxに対して
は機能しません。



File: KLICj.info, Node: Files & Dirs, Next: Signals, Prev: Sockets, Up: Unix

ファイルとディレクトリ
----------------------

unix ストリームに次のメッセージを送り、ファイルとディレクトリを処理しま
す。

 -- メッセージ on unix ストリーム: cd +PATH -RESULT
     ワーク・ディレクトリを PATH に変更します。変更が成功した場合、
     RESULT へ `0' を返し、それ以外の場合、`-1' を返します。これは、シス
     テム・コールの `chdir' に相当します。

 -- メッセージ on unix ストリーム: unlink +PATH -RESULT
     PATH で指定されたディレクトリの登録を削除します。削除が成功した場合、
     RESULT へ `0' を返し、それ以外の場合、`-1' を返します。これは、シス
     テム・コールの `unlink' に相当します。

 -- メッセージ on unix ストリーム: mktemp +TEMPLATE -FILENAME
     指定された TEMPLATE からユニークなファイル名を生成し、FILENAME へ返
     します。これは、C ライブラリ・ルーチンの `mktemp' に相当します。た
     だし、ライブラリ・ルーチンとは異なり、テンプレートは 6 個の終了文字 
     X を持つ必要がありません。何らかの理由で、ユニークなファイル名が作
     成できない場合、FILENAME へ空文字列を返します。

 -- メッセージ on unix ストリーム: access +PATH +MODE -RESULT
     パス名 PATH のファイルに、モード MODE でアクセス可能か否かをチェッ
     クします。その結果を RESULT へ返します。これは、C ライブラリ・ルー
     チンの `access' に相当します。ファイルがアクセス可能な場合、`0' を
     返し、それ以外の場合、`-1' を返します。

     MODE は、各ビットが以下に示す意味を持つ整数です。MODE に 0 を指定し
     た時は、ファイルが存在するか否かだけを調べます。
     4
          読み込み可
     2
          書き出し可
     1
          実行可

 -- メッセージ on unix ストリーム: chmod +PATH +MODE -RESULT
     パス名 PATH を持つファイルの許可モードを MODE に変更します。これは、
     システム・コールの `chmod' に相当します。モードの変更が成功した場合、
     RESULT へ `0' を返し、それ以外の場合、`-1' を返します。MODEは、標準
     的な Unix の許可ビットを持つ整数です。

 -- メッセージ on unix ストリーム: umask -OLDMASK
 -- メッセージ on unix ストリーム: umask -OLDMASK +NEWMASK
     現在のファイルの生成マスクを OLDMASK へ返します。引数が 2 個の場合、
     ファイル作成マスクに NEWMASK を設定します。これは、システム・コール
     の `umask' に相当します。



File: KLICj.info, Node: Signals, Next: Misc Unix Messages, Prev: Files & Dirs, Up: Unix

シグナル割込みの処理
--------------------
Unixシグナルは、 unix ストリームに対して次のようなメッセージを使用して、
整数のリストに変更します。

 -- メッセージ on unix ストリーム: signal_stream +SIGNAL -RESULT
     SIGNAL(整数値)で指定された unixシグナルを捕捉して報告します。引数 
     RESULT は `normal(STREAM)'になり、指定された種類のシグナルが到着し
     たとき、そのシグナル番号を Stream に送ります。例えば、シグナル 2(
     BSD と SVR4 での SIGINT )が見つかると、Stream は`[2|REST]' になりま
     す。その後、到着したシグナルは、REST に報告されます。

*制限事項*:
Unix の制限によって、シグナルを捕捉する前に同じシグナルの発生が 2 回を超
えると、シグナルは無視することがあります。



File: KLICj.info, Node: Misc Unix Messages, Next: Predicate Interface, Prev: Signals, Up: Unix

Unix ストリームへの種々のメッセージ
-----------------------------------

Unix ストリームに次のメッセージを送り、Unix の種々の機能を利用します。

 -- メッセージ on unix ストリーム: system +COMMAND -RESULT
     新たに生成したサブシェルで、 COMMAND(文字列)を実行し、終了コードを 
     RESULT へ返します。これは、システム・コールの `system' に相当します。

 -- メッセージ on unix ストリーム: getenv +NAME -VALUE
     名前 NAME の環境変数の値を VALUE へ返します。これは、ライブラリ・ルー
     チンの `getenv' に相当します。そのような環境変数が存在しない場合、
     整数 `0' を VALUE へ返します。

 -- メッセージ on unix ストリーム: putenv +STRING -RESULT
     最初の引数 STRING は、`NAME = VALUE' の形式にしてください。環境変数 
     NAME を VALUE で追加または更新します。これは、ライブラリ・ルーチン
     の `putenv' に相当します。追加または更新が成功した場合、RESULT へ 
     `0' を返し、それ以外の場合、0 以外の整数値を返します。

 -- メッセージ on unix ストリーム: kill +PID +SIG -RESULT
     PID で指定した 1 つのプロセスまたはプロセス・グループへシグナル SIG 
     を送り、送信が成功した場合、RESULT へ `0' を返し、失敗した場合、
     `-1' を返します。

 -- メッセージ on unix ストリーム: fork -PID
     現行プロセスのコピーである新しいプロセスを、フォークします。これは、
     システム・コールの `fork' に相当します。子プロセスの生成が成功した
     場合、親プロセスの PID へ子プロセスのプロセス ID を返し、子プロセス
     へ `0' を返します。

 -- メッセージ on unix ストリーム: fork_with_pipes -RESULT
     パイプを生成して、新しいプロセスをフォークします。新しいプロセスは、
     現行プロセスのコピーです。親プロセスでは、RESULT を 
     `parent(PID,IN,OUT)' で単一化します。ここで、PID は新たに作成された
     プロセスのプロセス ID です。新たに生成した子プロセスでは、RESULT を 
     `child(IN,OUT)' で単一化します。

     IN と OUT は パイプへの Unix I/O ストリームです。ここで、親の OUT 
     は出力ストリームであり、子の入力ストリーム IN に接続し、子の OUT は
     親の INに接続しています。



File: KLICj.info, Node: Predicate Interface, Prev: Misc Unix Messages, Up: Unix

述語インタフェース
------------------

いくつかの unix インタフェースを、 `unix' モジュール中で定義した述語とし
て提供しています。

 -- unix on predicate: argc -ARGC
     KLIC で使用しないコマンド行引数の数を ARGC へ返します。そのような引
     数は、`-'で始まらない最初の引数や、コマンド行の`--'の後から始まる引
     数です。

 -- predicate on unix: argv -ARGLIST
     KLIC で使用しないコマンド行引数を、文字列のリストとして ARGLIST へ
     返します。

 -- predicate on unix: exit +EXITCODE
     直ちに、終了コードの EXITCODE でプロセスを終了します。

 -- predicate on unix: times -UTIME -STIME -CUTIME -CSTIME
     ミリ秒単位でプロセス・タイムを返します。UTIME はユーザ・タイムであ
     り、STIME はシステム・タイムです。CUTIME と CSTIME は、それぞれ子プ
     ロセス用のものです。

     `HZ'(秒当たりのクロック数) が標準的な場所で定義されていない場合、シ
     ステムは 60 を仮定します。



File: KLICj.info, Node: Input and Output, Next: System Control, Prev: Unix, Up: Builtin and Library

入出力
======
KLIC は 2 種類の入出力操作群を提供しています。1 つは C 風のインタフェー
ス、もう 1 つは Prolog 風のインタフェースです。

C 風の機能は低レベルであり、速度とコード・サイズの両面で高性能です。しか
し、プロトタイプとデバッグのフェーズでは、Prolog 風の高レベルなインタフェー
スの方が、データ構造の入出力が直接可能なので有利になります。

* Menu:

* C-like I/O::                  C 風のインタフェースを用いた入出力
* Prolog I/O::                  Prolog 風のインタフェースを用いた入出力



File: KLICj.info, Node: C-like I/O, Next: Prolog I/O, Prev: Input and Output, Up: Input and Output

C 風のインタフェースを用いた入出力
----------------------------------

この節では、C 風のインタフェースを用いた入出力操作を説明します。

このインタフェースは、ファイル、ソケット、パイプなどへのストリームに対す
るメッセージとして提供しています。これらのストリームは、Unix ストリーム
へメッセージを送って獲得します(*Note 入出力用ストリームのオープン: I/O
Opening.)。

* Menu:

* Common Msgs (C style)::       C 風のインタフェースを用いた共通メッセージ
* Input Msgs (C style)::        C 風のインタフェースを用いた入力メッセージ
* Output Msgs (C style)::       C 風のインタフェースを用いた出力メッセージ



File: KLICj.info, Node: Common Msgs (C style), Next: Input Msgs (C style), Prev: C-like I/O, Up: C-like I/O

C 風のインタフェースを用いた共通メッセージ
..........................................

次に示すメッセージは、C 風の入出力用の入力ストリームと出力ストリームの両
方に利用できます。

 -- メッセージ on C 風の I/O : feof -RESULT
     ストリームがファイルの終端の場合、RESULTへ `1' を返し、それ以外の場
     合、`0'を返します。これは、ライブラリ・ルーチンの `feof' に相当しま
     す。

 -- メッセージ on C 風の I/O : fseek +OFFSET +PTRNAME -RESULT
     オフセットとポインタ名を、それぞれ OFFSET と PTRNAME に指定してスト
     リームの位置を変更します。PTRNAME が0のときファイルの先頭からの、1
     のとき現在位置からの、2のときファイルの末尾からのオフセットを、符合
     付き整数で指定します。変更が成功した場合、RESULTへ `0' を返し、それ
     以外の場合、`-1' を返します。

     あまり大きなファイル(long int が32ビットのシステムでは128MBより大)
     を対象とした場合、整数型の値の範囲による制限のため、このメッセージ
     では任意位置への移動はできない場合があることに注意して下さい。

 -- メッセージ on C 風の I/O : ftell -RESULT
     現在の位置(バイト単位)のオフセットを、 RESULT へ返します。

     あまり大きなファイル(long int が32ビットのシステムでは128MBより大)
     を対象とした場合、整数型の値の範囲による制限のため、得られた位置が
     誤っている場合があることに注意して下さい。

 -- メッセージ on C 風の I/O : fclose -RESULT
     ストリームをクローズします。クローズが成功した場合、RESULTへ `0' を
     返し、それ以外の場合、`-1' を返します。クローズの後、`sync/1' の他
     はストリームにメッセージを送ってはなりません。

 -- メッセージ on C 風の I/O : sync -RESULT
     RESULT へ `0' を返します。先行するすべてのメッセージが、既に処理済
     みであることを確認するのに有効です。



File: KLICj.info, Node: Input Msgs (C style), Next: Output Msgs (C style), Prev: Common Msgs (C style), Up: C-like I/O

C 風のインタフェースを用いた入力メッセージ
..........................................
次のメッセージが C 風の入出力用の入力ストリームに利用できます。

 -- メッセージ on C 風の I/O : getc -C
     ストリームから 1 バイトを読み込み、C へ返します。ファイルの終端の場
     合、`-1' を返します。

 -- メッセージ on C 風の I/O : ungetc +C
      1 バイトの C を、ストリームにプッシュ・バックします。

 -- メッセージ on C 風の I/O : fread +MAX -STRING
     ストリームから最大 MAX バイトを読み込み、そのデータを、バイト文字列
     として STRING へ返します。現在の実装では、4,096 バイトまでしか処理
     できません。読み込んだ文字列の長さが、指定した最大値 MAX より小さい
     場合がありますので、注意してください。この現象は、標準ファイルでは
     ファイルの終端で発生し、パイプやソケットではいつでも発生する可能性
     があります。

 -- メッセージ on C 風の I/O : linecount -COUNT
     これまでに検出した改行文字の数を、COUNT へ返します。ファイルの第 1 
     行では、まだ改行文字を検出していないので `0' を返します。行数のカウ
     ントが 1 で始まる場合(通常)は、改行文字の数に 1 を加えることで行数
     が計算できます。

     ただし、`fseek/2' メッセージを使用する場合、この行数は正しく計算さ
     れません。



File: KLICj.info, Node: Output Msgs (C style), Prev: Input Msgs (C style), Up: C-like I/O

C 風のインタフェースを用いた出力メッセージ
..........................................
次のメッセージが C 風の入出力用の出力ストリームに利用できます。

 -- メッセージ on C 風の I/O : putc +C
      1 バイトの C をストリームに書き出します。

 -- メッセージ on C 風の I/O : NUMBER
      1 バイトの NUMBER をストリームに書き出します。これは、
     `putc(NUMBER)' に相当します。

 -- メッセージ on C 風の I/O : fwrite +STRING -RESULT
     バイト文字列 STRING の内容をストリームに書き出します。実際に書き出
     したバイト数を RESULT へ返します。実際に書き出したバイト数は、
     STRING の長さより短くなる場合があります。

 -- メッセージ on C 風の I/O : fwrite +STRING
     バイト文字列の STRING の内容をストリームに書き出します。引数 RESULT 
     を持つ `fwrite' のメッセージと違って、STRING 中のすべてのバイトが出
     力されるまで待ちます。これは、インターネットのソケットやパイプのよ
     うな、出力に予測できない時間を必要とするストリーム用には望ましくあ
     りません。

 -- メッセージ on C 風の I/O : fflush -RESULT
     ストリームに残っている出力をフラッシュします。フラッシュが成功した
     場合、RESULT へ `0' を返し、それ以外の場合、`-1' を返します。



File: KLICj.info, Node: Prolog I/O, Prev: C-like I/O, Up: Input and Output

Prolog 風のインタフェースを用いた入出力
---------------------------------------

演算子順位文法に基づく Prolog 風の項の処理機能を持つ Unix インタフェース
のストリームは、以下に示すモジュールの `klicio' 述語によって獲得できます。

KLIC の項の構文は、Edinburgh Prolog によく似ていますが、細かい点で異なっています。
詳細については、
*Note 記号アトムの表記: Notation of Atoms、
*Note 整数の表記: Notation of Integers、
*Note 浮動小数点数の表記: Notation of Floats、
*Note ファンクタの表記: Notation of Functors、
*Note リストの表記: Notation of Lists、
*Note ベクタの表記: Notation of Vectors、
*Note 文字列の表記: Notation of Stringsなどを参照してください。

* Menu:

* Opening Prolog I/O::          Prolog 風の I/O ストリームのオープン
* Common Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Input Msgs (Prolog style)::   Prolog 風のインタフェースを用いたメッセージ
* Output Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Wrapped Terms::               ラップした項



File: KLICj.info, Node: Opening Prolog I/O, Next: Common Msgs (Prolog style), Prev: Prolog I/O, Up: Prolog I/O

Prolog 風の I/O ストリームのオープン
....................................

 -- klicio  on predicate: klicio ?STREAM
     Prolog 風の項のインタフェースに対応するメッセージ・ストリームを 
     STREAM へ返します。獲得したストリームは、 Unix のインタフェース・ス
     トリームのように機能します。つまり、このストリームは、実際に入出力
     を行うメッセージ・ストリームを獲得するために使用します。このストリー
     ムを介して獲得した I/O ストリームは、通常の C 風の I/O メッセージに
     加えて、この節で説明する Prolog 風の項の 入出力に対するメッセージも
     受け取ります。


     パーシングやアンパーシング用のモジュールは、無視できない大きさなの
     で、Prolog 風の項の入出力を必要としないプログラムに対して、そのモジュー
     ル*なし*で実行できるように、別モジュールとして提供します。

 -- メッセージ on klicio ストリーム: stdin -RESULT
 -- メッセージ on klicio ストリーム: stdout -RESULT
 -- メッセージ on klicio ストリーム: stderr -RESULT
 -- メッセージ on klicio ストリーム: read_open +PATH -RESULT
 -- メッセージ on klicio ストリーム: write_open +PATH -RESULT
 -- メッセージ on klicio ストリーム: append_open +PATH -RESULT
 -- メッセージ on klicio ストリーム: update_open +PATH -RESULT

     これらのメッセージは、Prolog 風の I/O ストリームをオープンします。
     実際に入出力を実行するために、(`klicio' ストリーム自身では*ない*)
     Prolog 風の I/O ストリームに送るメッセージについては、次に述べます。

     これらのメッセージは、返された I/O ストリームが C 風の I/O ストリー
     ム用メッセージに*加えて*、Prolog 風の項の入出力用メッセージも解釈す
     る他は、 `Unix' ストリームに対するメッセージと全く同じように機能し
     ます。

     Prolog 風の I/O ストリームは、演算子定義を持ちます。さらに、各スト
     リームは異なる演算子定義を持つことができます。したがって、演算子を
     あるストリームに追加したり、あるストリームから取り除いたりしても、
     他のストリームで使用する演算子には、影響*しません*。各ストリームは、
     生成後すぐにデフォルトの演算子の集合を持ちます。



File: KLICj.info, Node: Common Msgs (Prolog style), Next: Input Msgs (Prolog style), Prev: Opening Prolog I/O, Up: Prolog I/O

Prolog 風のインタフェースを用いた共通メッセージ
...............................................

以下に示す、C 風の I/O ストリーム用メッセージは、Prolog 風の I/O ストリー
ムに使用できます。

 -- メッセージ on Prolog 風の I/O : feof -RESULT
 -- メッセージ on Prolog 風の I/O : fseek +OFFSET +PTRNAME -RESULT
 -- メッセージ on Prolog 風の I/O : ftell -RESULT
 -- メッセージ on Prolog 風の I/O : fclose -RESULT
 -- メッセージ on Prolog 風の I/O : sync -RESULT
     詳細については、*Note C 風のインタフェースを用いた共通メッセージ:
     Common Msgs (C style)。

 -- メッセージ on Prolog 風の I/O : addop +OP +TYPE +PREC
     優先順位 PREC を持つ型 TYPE の演算子 OP を追加します。

 -- メッセージ on Prolog 風の I/O : rmop +OP +TYPE
     型 TYPE の演算子 OP を取り除きます。



File: KLICj.info, Node: Input Msgs (Prolog style), Next: Output Msgs (Prolog style), Prev: Common Msgs (Prolog style), Up: Prolog I/O

Prolog 風のインタフェースを用いた入力メッセージ
...............................................

 -- メッセージ on Prolog 風の I/O : gett -TERM
     関連する入力ストリームから KLIC の構文項の形で TERM へ読み込みます。
     構文解析に失敗した場合、メッセージを `stderr' に出力した後、別の項
     を読み込みます。ファイルの終了時には、アトム `end_of_file' を返しま
     す。

 -- メッセージ on Prolog 風の I/O : getwt -RESULT
     関連する入力ストリームから KLIC の構文項の形で TERM へ読み込み、結
     果をRESULT へ返します。構文解析が成功した場合、RESULT は、
     `normal(WRAPPEDTERM) 'の形式になります。ここで、WRAPPEDTERM とは、
     読み込んだ項の基底項表現のことです。変数は、変数名の情報を持つ基底
     項として表現します。構文解析が失敗した場合、メッセージを `stderr' 
     に出力した後、別の項を読み込みます。ファイルの終了時には、
     `normal(end_of_file) 'を返します。

     ラップした項の操作については、*Note ラップした項: Wrapped Terms。

以下に示す、C 風の I/O ストリーム用メッセージは、Prolog 風の I/O ストリー
ムに使用できます。

 -- メッセージ on Prolog 風の I/O : getc -C
 -- メッセージ on Prolog 風の I/O : ungetc +C
 -- メッセージ on Prolog 風の I/O : fread +MAX -STRING
 -- メッセージ on Prolog 風の I/O : linecount -COUNT
     詳細については、*Note C 風のインタフェースを用いた入力メッセージ:
     Input Msgs (C style)。



File: KLICj.info, Node: Output Msgs (Prolog style), Next: Wrapped Terms, Prev: Input Msgs (Prolog style), Up: Prolog I/O

Prolog 風のインタフェースを用いた出力メッセージ
...............................................

 -- メッセージ on Prolog 風の I/O : putt +TERM
 -- メッセージ on Prolog 風の I/O : puttq +TERM
 -- メッセージ on Prolog 風の I/O : putwt +WRAPPEDTERM
 -- メッセージ on Prolog 風の I/O : putwtq +WRAPPEDTERM

     項 TERM やラップした項 WRAPPEDTERMを、関連する出力ストリームへ書き
     出します。

     文字 `q' の付いて*いない*メッセージは、再び、読み込みをする必要があ
     る場合でも、記号アトムを 2 つの引用符で囲みません。しかし、現在のと
     ころでは `q' の付いたメッセージと全く同じように機能します。

     現在の版の出力フォーマットは、マシンが読めるだけで、人間が読める形
     式ではありません。つまり、演算子を全く使用しないですべてのアトムを
     括弧で囲んでいます。

     ラップした項の操作については、*Note ラップした項: Wrapped Terms。

以下に示す、C 風の I/O ストリーム用メッセージは、Prolog 風の I/O ストリー
ムに使用できます。

 -- メッセージ on Prolog 風の I/O : putc +C
 -- メッセージ on Prolog 風の I/O : NUMBER
 -- メッセージ on Prolog 風の I/O : fwrite +STRING -RESULT
 -- メッセージ on Prolog 風の I/O : fwrite +STRING
 -- メッセージ on Prolog 風の I/O : fflush -RESULT
     詳細については、*Note C 風のインタフェースを用いた出力メッセージ:
     Output Msgs (C style)。

項を終了させるピリオドは、これらのメッセージでは書き出せないので注意して
ください。ピリオドと空白や改行文字は通常、再び、読み込みをするために書き
出す必要があります。以下に示すゴール列は、`/tmp/foo.bar'という名前のファ
イルをオープンして、変数X の完全な具体化を待ち、後にピリオドと改行が続く 
Prolog 風の形式で出力します。

     klicio:klicio([write_open("/tmp/foo.bar", normal(S))]),
     S = [putt(X), putc(0'.), nl].

 -- メッセージ on Prolog 風の I/O : nl
     改行コードを出力します。メッセージの `putc(10)' を同じストリームに
     送ることと、同じ意味になります。

Prolog 風のI/Oストリームも、`putc/1' や `getc/1' といった C 風の入出力が
受け取るメッセージのすべてを受け取るので注意してください(*Note C 風のイ
ンタフェースを用いた入出力: C-like I/O.)。



File: KLICj.info, Node: Wrapped Terms, Prev: Output Msgs (Prolog style), Up: Prolog I/O

ラップした項
............

変数を含む項のメタレベルの操作を可能にするため、KLIC では "ラップした項
(wrapped term)" と呼ばれるデータ表現を提供しています。ラップした項は、そ
の中に変数を含まない基底項です。ラップした項は、以下に示す形式を持ってい
ます。

variable(VARNAME)
     VARNAME という名前文字列を持つ変数
atom(ATOM)
     記号アトム ATOM
integer(INT)
     整数 INT
floating_point(FLOAT)
     浮動小数点数 FLOAT
list([CAR|CDR])
     CAR と CDR で構成される コンス・セル；CAR と CDR は自己再帰的なラッ
     プした項
functor(FUNCTOR(ARG, ...)
     ファンクタの構造；その引数の(ARG, ...)は自己再帰的なラップした項
vector({ELEM, ...})
     ベクタ；その要素の(ELEM, ...)は自己再帰的なラップした項
string(STR)
     文字列 STR
unknown(TERM)
     不明データ；この場合ラッピングが不正確になることがあります

例えば、以下の項

     f(a, X, {3, ["abc"|X]}, 3.14)  を

ラップした表現は、以下のようになります。

     functor(f(atom(a),
             variable("X"),
             vector({integer(3), list([string("abc")|variable("X")])}),
             floating_point(3.14))).

次の述語は、ラップした項を通常の項に変換します。

 -- predicate on 変換: unwrap -WRAPPED ?TERM
     ラップした項 WRAPPED を通常の項 TERM に変換します。

ラップした項は、通常、入力操作の結果として獲得します(*Note Prolog 風のイ
ンタフェースを用いた入力メッセージ: Input Msgs (Prolog style).)。

ラップした項も、通常の KL1 の項と変わりがないので、通常のユーザ・プログ
ラムで作成できます。通常の項を、ラップした項に変換する次の述語も、ある場
合には有効です。

 -- predicate on variable: wrap ?TERM -WRAPPED
     通常の項 TERM を、ラップした項 WRAPPED に変換します。

     現在の版では、すべての変数に同じ名前の `_' を与えています。したがっ
     て、ある項をラップし、その結果をアンラップすると、元の項の中のすべ
     ての変数が、同じ名前で参照できるようになってしまいます。これはバグ
     ですので、将来のバージョンでは修復する予定です。

     TERM が同じ変数を複数個含んでいるとき、並行して演算を続けていると、
     変数を具体化することがあります。このような場合、同じ変数を 2 つ含む
     項は、1 つは変数のまま、もう 1 つは変数でない項を含む形でラップした
     項に変換されるかもしれません。このことは、この述語の仕様が内包する
     特有の問題ですので、おそらく修復は無理でしょう。したがって、この述
     語を非基底項 (non-ground terms) に適用する場合、デバッギング・ユー
     ティリティといった、メタレベルのプログラムに限定すべきです。



File: KLICj.info, Node: System Control, Prev: Input and Output, Up: Builtin and Library

システム動作の制御
==================

以下に示す述語は、`system_control' モジュール中に提供しています。

 -- predicate on system_control: postmortem +MODULE +GOAL -RESULT
     メイン・プログラムの正常終了や異常終了の後に実行する後処理を、登録
     します。GOAL は、ゴールの後処理の述語と引数を指定するファンクタ構造
     にする必要があります。 MODULE は、後処理を行う述語のモジュールを指
     定する記号アトムにする必要があります。1 つのゴールだけを指定できま
     す。この場合、コンマで区切られたゴールの並びは許していません。

     登録が終了したら RESULT を `[]' で単一化します。登録の完了まで待ち
     状態になるので、他の処理は実行しません。

     この述語が何度も呼び出された場合、最後の登録が有効となります。

 -- predicate on system_control: gc -BEFORE -AFTER
     ガーベージ・コレクションを要求し、ガーベージ・コレクションの前後の
     ヒープ・サイズを、それぞれワード単位で、BEFORE と AFTER へ返します。
     ワードのサイズは、インストールで使用した C 言語システムの `long' 型
     のサイズと同じです。

     並列実装では、局所的な記憶域に対するガーベージ・コレクションだけが
     要求されます。大域的なガーベージ・コレクションの要求はできません。



File: KLICj.info, Node: Timer, Next: Random Numbers, Prev: System Control, Up: Builtin and Library

タイマ
======

KLIC では実時間タイマを提供しています。Unix では 1 プロセスにつき 1 タイ
マしか提供されていませんが、KLIC ではこの機構を仮想化して必要な個数のタ
イマを使用できます。

実時間タイマが利用できないホストシステム上の実装では、この機能は提供して
いません。

時間の値は(時刻、時間間隔ともに) `time(DAY, SEC, USEC)' の形式の項で表現
します。ここで、 DAY, SEC and USEC はそれぞれ日、秒、マイクロ秒を表す負
でない整数です。また、SEC は 86,000 ( 1 日)未満、 USEC は 1,000,000 (1 
秒)未満でなければなりません。

次の述語は、モジュール `timer' 中に提供しています。

 -- 述語 on timer: get_time_of_day -TIME
     1970 年 1 月 1 日の真夜中を起点とし、秒とマイクロ秒で表現した現在の
     時刻を、 TIME に返します。

     得られる時刻は、この述語が実際に実行されたときの時刻です。ゴールの
     実行順序は KLIC のシステムによることに注意して下さい。報告される時
     間は、このゴールの親ゴールがリダクションされてから、TIME の値が検査
     されるまでの間であることのみ、保証されています。

     また、報告される時間は、この述語を実行するタスクが動作している OS 
     が、返すものであることに注意して下さい。分散システムにおいては、各
     システム構成要素の時刻は完全に一致しているとは限りません。

 -- 述語 on timer: add TIME1 TIME2 -TIME
 -- 述語 on timer: sub TIME1 TIME2 -TIME
     それぞれ、二つの時間値の加算および減算を行います。

 -- 述語 on timer: compare TIME1 TIME2 -RESULT
     二つの時間値 TIME1 および TIME2 を比較し、結果を RESULT に返します。
     結果は、TIME1 が TIME2 より小さい(早い)場合は `<'、等しい場合は `='、
     TIME1 が TIME2 より大きい(遅い)場合は `>' になります。

 -- 述語 on timer: instantiate_at TIME -VAR
 -- 述語 on timer: instantiate_after INTERVAL -VAR
     指定された時間に、VAR を記号アトム `[]' と単一化します。前者の述語
     は指定された*時刻に*この動作を行いますが、後者は指定された*時間間隔
     後に*この動作を行います。指定時間をすでに過ぎていた場合は、変数はた
     だちに単一化される場合があります。

     単一化操作には、任意時間の遅れが生じる可能性があることに注意して下
     さい。合理的な実装では、この遅れは短いはずです。

 -- 述語 on timer: instantiate_every INTERVAL STOP -VAR
     VAR を記号アトム `[]' のリストで順に単一化していきます。リストの最
     初の要素は指定した時間間隔後に単一化され、第二要素はさらに同じ時間
     間隔を経て単一化されます。この操作は引数 STOP が単一化されるまで繰
     り返され、リストの終端を生成して終了します。

     単一化操作には、任意時間の遅れが生じる可能性があることに注意して下
     さい。合理的な実装では、この遅れは短いはずです。



File: KLICj.info, Node: Random Numbers, Prev: Timer, Up: Builtin and Library

乱数生成器
==========

オブジェクトクラス `random_numbers' により、疑似乱数を生成することができ
ます。この乱数生成器は `nrand48' によるものであり、ホストシステムに 
`nrand48' がない場合はこの機能は利用できません。

 -- オブジェクト生成 on random_numbers: new -RANDOMS RANGE
 -- オブジェクト生成 on random_numbers: new -RANDOMS RANGE SEED
     0 から RANGE - 1 を含んだ範囲をとる整数の疑似乱数からなる、無限長の
     リストを RANDOMS に返します。 RANGE は正の整数です。

     任意指定の引数 SEED には乱数生成の種を指定します。同じ種を与えた場
     合、リストの要素は同じになることが保証されています。

     リストは仮想的に無限ですが、リスト要素はプログラムでその値を検査す
     ることによって、遅延的に計算されることに注意して下さい。



File: KLICj.info, Node: Using KLIC, Next: Type Index, Prev: Builtin and Library, Up: Top

KLIC の使い方
*************

この章では、KLIC システムの使い方について説明します。

* Menu:

* Compiling::                   KLIC におけるプログラムのコンパイル
* Running::                     KLIC におけるプログラムの実行
* Tracing::                     プログラム実行のトレース
* Install::                     インストール
* Distributed KLIC::            分散 KLIC
* Shared-Memory KLIC::          共有メモリ KLIC



File: KLICj.info, Node: Compiling, Next: Running, Prev: Using KLIC, Up: Using KLIC

KLIC におけるプログラムのコンパイル
===================================

インストールが完了すると、`klic' コマンドでKL1 プログラムを C 言語プログ
ラムへコンパイルし、実行可能コードを生成することが可能になります。
 `klic' というプログラムは、様々なオプションが可能なコンパイラ・ドライバ
です。

* Menu:

* Command for Compilation::     コンパイル用コマンド
* Compiler Options::            コンパイラ・オプション
* Mechanism of Compilation::    KLIC コンパイラの動作内容



File: KLICj.info, Node: Command for Compilation, Next: Compiler Options, Prev: Compiling, Up: Compiling

コンパイル用コマンド
--------------------

引数に、拡張子 `.kl1' が付いた KL1 ソース・プログラム・ファイル名を指定
して、`klic' コマンドを実行すると、 KL1 プログラムは C 言語にコンパイル
され、実行可能コードが生成されます。

例えば、 XXX.kl1 をコンパイルしてコードを生成する場合、次のように入力し
ます:

     % klic XXX.kl1

実行結果は `a.out' となります。実行結果の名前を `YYY' としたい場合、次の
ように入力します。

     % klic -o YYY XXX.kl1

例えば、プログラムが `XXX.kl1' 、`YYY.kl1' 、`ZZZ.kl1' のように複数個の
ソース・ファイルに分割されている場合、次のように入力すると、一括してコン
パイルとリンクができます。

     % klic XXX.kl1 YYY.kl1 ZZZ.kl1

複数個の KL1 ソース・ファイルを別個にコンパイルして、後でリンクすること
もできます。リンケージ・エラーを避けるために、次のように `-c' オプション
を指定して、リンク前にコンパイル・コマンドの実行を終わらせる必要がありま
す。

     % klic -c XXX.kl1
     % klic -c YYY.kl1
     % klic -c ZZZ.kl1

最後に、次のように入力して、複数のコンパイル結果をリンクすることができま
す。

     % klic XXX.o YYY.o ZZZ.o

コンパイラ・オプションの詳細については、*Note コンパイラ・オプション:
Compiler Options。

直接 C でかかれたプログラム(例えば `CCC.c' と `DDD.c')を
 KL1 で書かれたプログラム(例えば `XXX.kl1' と `YYY.kl1')のリンクは、次の
ように入力するだけで実行できます。

     % klic CCC.c DDD.c XXX.kl1 YYY.kl1

ファイル指定の順番は影響しません。
 C の関数は KL1 のインライン展開コード(*Note C 言語コードのインライン挿
入: Inline C Code.)  から呼び出すことが出来ます。



File: KLICj.info, Node: Compiler Options, Next: Mechanism of Compilation, Prev: Command for Compilation, Up: Compiling

コンパイラ・オプション
----------------------

コンパイル・コマンド klic のオプションの利用方法を、以下に示します。

-c
     再配置可能オブジェクトを生成し、klic コマンドを終了します。リンクは
     行ないません。

-C
      C 言語への変換を終了し、klic コマンドを終了します。

-d
     実際に実行するコマンド列を表示します。表示するだけで実行はしません。 
     `-v' を仮定します。

-D DATABASE_MANAGER
     指定されたデータベース管理プログラムを使用します。

-g
      dbx 、 gdb などのデバッガ用の情報を含んだ実行可能コードを生成しま
     す。

-I DIRECTORY
     指定されたインクルード・パスを C コンパイル時に使用します。

-K KLIC_COMPILER
     指定された変換プログラムを KL1 から C への変換時に使用します。

-l LIBRARY
     指定されたライブラリをリンク時に使用します。

-L DIRECTORY
     指定されたライブラリ・パスをリンク時に使用します。

-o FILE
     指定された実行可能コードファイルの名前を生成します。

-O
-OLEVEL
     指定された最適化レベルで、コンパイルします。ゼロ以外の最適化レベル
     が指定されたとき、いくつかの付加的な最適化フラグも C コンパイラに渡
     します。そのような付加的な最適化フラグは、システムに依存するため、 
     KLIC システムのインストール手続きの際に決定されます。

     このオプションでは、 `-O' と LEVEL の間に空白があってはなりません。

-P PARALLEL
     サブタスク( C コンパイラなど)を並列で実行します。最大時には、並列の
     サブタスクを同時にフォークします。

-R
     ファイルの日付とは無関係に、再コンパイルをします。

-S
     アセンブリ・コードを生成し、klic コマンドを終了します。

-n
     デバッグなし実行時ライブラリをリンクします。このオプションが省略さ
     れた場合、デバッグあり実行時ライブラリをリンクします。

-v
     実際に実行したすべてのコマンドを、標準エラー出力に出力します。

-xDIRECTORY
     指定されたディレクトリ中のデータベース・ファイル `klic.db' を使用し
     ます。また、 `atom.c' 、 `funct.c' 、 `predicates.c' や対応するオブ
     ジェクトも指定されたディレクトリに置きます。このオプションは、リン
     クするプログラムが複数のディレクトリに分散している場合に便利です。

-XDIRECTORY
     データベース・ファイル `klic.db' が存在しない場合、指定されたディレ
     クトリ下のデータベース初期化ファイル `klicdb.init' から `klic.db' 
     を作成します。このオプションが省略された場合、デフォルトのライブラ
     リ・ディレクトリを仮定します。

次に示す環境変数によって、コンパイラのデフォルトの動作を変えることができ
ます。コンパイル時に指定されたオプションの方は、環境変数の値よりも優先し
ます。

KLIC_LIBRARY
     実行時ライブラリ用のディレクトリです。
      `-X' オプションの方を優先します。

KLIC_DBINIT
     初期データベース用のディレクトリです。デフォルトは実行時ライブラリ
     用のディレクトリです。

KLIC_COMPILER
      KL1 から C への変換プログラムです。
      `-K' オプションの方を優先します。

KLIC_DBMAKER
     データベース管理プログラムです。
      `-D' オプションの方を優先します。

KLIC_INCLUDE
     コンパイル時のインクルード・パスです。
      `-I' オプションの方を優先します。

KLIC_CC
     使用する C コンパイラです。

KLIC_CC_OPTIONS
     コンパイラ・オプションです。

KLIC_LD
     使用するリンカです。

KLIC_LD_OPTIONS
     リンカ・オプションです。



File: KLICj.info, Node: Mechanism of Compilation, Prev: Compiler Options, Up: Compiling

KLIC コンパイラの動作内容
-------------------------

KL1 プログラムのコンパイル過程や実行可能コードの生成過程を知ることによっ
て、 KLIC の使い方の理解を深めることができます。

KLIC システムは、以下のように 3 個のモジュールで構成されます。

   *  KLIC コンパイラ
   *  KLIC データベース管理プログラム
   *  KLIC 実行時ライブラリ

KLIC コンパイラは、KL1 プログラムを C 言語プログラムにコンパイルします。
KLIC コンパイラは同時に、`.extファイル' も生成します。このファイルは、プ
ログラムで使用しているアトムとファンクタの情報などを持ちます 。リンクす
る個々のプログラムの `.ext' ファイル中にある情報は、後でデータベース管理
プログラムによってマージされ、 `atom.h' 、 `funct.h' 、 `atom.c' 、 
`funct.c' 、 `predicates.c' になります。

 C コンパイラは、KLIC コンパイラが生成した C プログラムをコンパイルしま
す。その際、ヘッダ・ファイル `atom.h' 、 `funct.h' を使用します。
 `atom.c' 、 `funct.c' 、`predicates.c' もコンパイルして、実行時ライブラ
リとリンクします( `predicates.c' は、デバッグあり実行時ライブラリを使用
するときだけリンクします)。

コンパイル、データベース管理、およびリンクは、コンパイラ・ドライバ・プロ
グラム `klic' が制御します。この klic プログラムは、 `cc' と `make' を組
み合わせた機能に類似した機能を持っています。
 `cc' は、 C プリプロセッサ、 C コンパイラ・カーネル、およびリンカを制御
します。同様に、 `klic' は、 KL1 から C へのコンパイラ、 C コンパイラ、 
KL1 プログラムのデータベース管理プログラム、およびリンカを制御します。
 `make' は、ファイルの日付をチェックし、コンパイルが必要なファイルだけを
コンパイルします。
 `klic' も `make' と同様の処理を行います。



File: KLICj.info, Node: Running, Next: Tracing, Prev: Compiling, Up: Using KLIC

KLIC におけるプログラムの実行
=============================

生成された実行可能コードは、簡単に動かせます。
 KL1 プログラムをコンパイルして、実行可能コードを `a.out' に出力した場合、
ファイル名 `./a.out' を使用中のシェルに渡すだけで実行できます。

`main' モジュール中の引数なし述語 `main' が、最初に実行されるゴールにな
ります(*Note 初期ゴール: Initial Goal.)。

* Menu:

* Runtime Switches::            実行時オプション



File: KLICj.info, Node: Runtime Switches, Prev: Running, Up: Running

実行時オプション
----------------

実行可能コードを動かす際、以下に示すオプションが利用できます。

-h size
     ワード単位のヒープの初期サイズです。コピー方式のガーベージ・コレク
     ションを採用しているので、実際に使用するヒープ・サイズは、この 2 倍
     になります。ヒープ・サイズは、(例えば、`2097152' のように)数値を直
     接指定したり、
      2^10 単位や 2^20 単位で `k' や `m' を数字の後ろに付けて(`2048k' や 
     `2m' のように)指定したりできます。このオプションが省略された場合、
     初期サイズはマクロの `HEAPSIZE' によって決定します。配布版では、 
     HEAPSIZE は 24k になっています。
      1 ワードの長さは、C の`long int'型と同じです。実際の長さは、使用す
     るハードウェアや C コンパイラに依存します。ヒープ・サイズは、 `-H' 
     や `-a' オプションに従って自動的に増加します。

-H SIZE
     ワード単位の最大のヒープ・サイズです。ヒープは、指定されたサイズま
     では自動的に拡張します。このオプションが省略された場合、無限大を仮
     定します。

-a RATIO
     ヒープ領域中でアクティブ・セル(ゴミでないセル)が占める割合の上限で
     す。浮動小数点数で指定してください。アクティブ・セルの占有する割合
     が、指定された上限値を超えると、 `-H' オプションで指定された最大サ
     イズを超えない限り、ヒープ・サイズを、次回のガーベージ・コレクショ
     ンで 2 倍にします。このオプションが省略された場合、0.5 を仮定します。

-g
     ガーベージ・コレクションに要した時間を計測します。ヒープが小さいと
     ガーベージ・コレクションは非常に短い時間で行うので、計測オーバヘッ
     ドの方が大きくなってしまう可能性が高くなります。このオプションが省
     略された場合、ガーベージ・コレクションの計測は行いません。

-s
     中断情報を計測します。プログラムの実行が終了すると、中断した述語と
     その中断回数を報告します。このオプションは、デバッグあり実行時ライ
     ブラリをリンクした場合にだけ有効です。このオプションを省略しても、
     デバッグあり実行時ライブラリがリンクされるので、中断情報を計測しま
     す(*Note コンパイラ・オプション: Compiler Options.)。

-t
     トレース状態で、プログラムの実行を開始します(*Note プログラム実行の
     トレース: Tracing.)。このオプションは、デバッグあり実行時ライブラリ
     をリンクした場合にだけ有効です。このオプションを省略しても、デバッ
     グあり実行時ライブラリがリンクされるので、トレース状態になります。
     デバッグなし実行時ライブラリをリンクさせる場合には、コンパイル時の
     オプションで指定します(*Note コンパイラ・オプション: Compiler
     Options.)。

すべての実行可能ゴールが実行を終了すると、プログラムは停止します。デバッ
グあり実行時ライブラリがリンクされている場合、(実行可能ゴールは存在しな
いが)、入力データを待って中断しているゴールが存在した場合、中断の原因と
なっているゴールが探索されて報告されます。デバッグなし実行時ライブラリが
リンクされている場合は、中断しているゴールの数だけが報告されます。




File: KLICj.info, Node: Tracing, Next: Install, Prev: Running, Up: Using KLIC

プログラム実行のトレース
========================

KLIC では、"スパイ"(ブレーク・ポイント)機能を持つデバッグ・トレーサを提
供します。

* Menu:

* Preparing for Trace::         トレース実行の準備
* Trace Ports::                 トレース・ポート
* Output of Tracer::            トレース表示のフォーマット
* Controlling Trace::           トレース制御コマンド
* Spying::                      スパイ
* Port Control::                トレース・ポートのコマンド
* Display Control::             表示を制御するコマンド
* Dumping Goals::               ゴールのダンプ
* Misc Trace Commands::         その他のコマンド
* Perpetual Suspension::        永久中断の探索



File: KLICj.info, Node: Preparing for Trace, Next: Trace Ports, Prev: Tracing, Up: Tracing

トレース実行の準備
------------------

トレース機能を使うには、プログラムをデバッグありの実行時ライブラリでリン
クする必要があります。特に指定がなければ、デバッグありの実行時ライブラリ
がリンクされますが、コンパイル・コマンドの `klic' に `-n' オプションを指
定すれば、トレースは行われません。

トレース対象のプログラムを、既に、`-n' オプションでコンパイル・リンクし
ている場合でも、プログラムを、初めから再コンパイルする必要はありません。
このような場合、 `-n' オプションなしで再度 `klic' コマンドを実行すると、
オブジェクトをデバッグありの実行時ライブラリとリンクするだけなので、短時
間の操作で済みます。

プログラムの実行をトレースするには、`-t' オプションを付けてプログラムを
実行するだけです(*Note 実行時オプション: Runtime Switches.)。



File: KLICj.info, Node: Trace Ports, Next: Output of Tracer, Prev: Preparing for Trace, Up: Tracing

トレース・ポート
----------------

 KL1 プログラムの実行の様子を以下に示します。

  1. 初期ゴールの `main：main' は、実行するゴールを貯めておくためのゴー
     ル・プールに入れられます。

  2. 1 つのゴールがゴール・プールから取り出されます( `CALL' ポート)。

  3. ゴールは、プログラム節とマッチングされます。

  4. ゴールと一致する節があれば、ゴールはサブゴールにリダクションし、そ
     れらのサブゴールはゴール・プールに戻されます( `REDUCE' ポート)。

  5. ゴールと一致する節がない場合は、計算全体が放棄されます( `FAIL' ポー
     ト)。

  6. ゴール引数の値やそれらの構造が確定していないため、ゴールと一致する
     節があるか否かを決定できない場合、ゴールは必要な値が揃うまで、ゴー
     ルを貯めておくための別のゴール・プールに入れられます( `SUSPEND' ポー
     ト)。

  7. ゴール・プールにゴールが残っていれば、ステップ 2 にループします。

ゴールの実行は、上記した 4 つのポイント、すなわち 2 、 4 、 5 、 6 番が
トレースされます。このような対象ポイントは "トレース・ポート"と呼ばれ、
それぞれ `CALL' 、 `REDUCE' 、 `FAIL' 、`SUSPEND' ポートと呼びます。

Prolog の 4 ポート・トレース・モデルに慣れ親しんでいれば、 Prolog の他の 
2 つのポートの `EXIT' と `REDO' がないことを疑問に思うかもしれません。
 KL1 プログラムは、バックトラックをしないので `REDO' ポートは存在しませ
ん。
 `EXIT' ポートは、次の 2 つの理由によってトレースされません。1 つは、ゴー
ル - サブゴール階層のすべてについて、実行履歴を維持することは、 Prolog 
のような逐次処理言語に比べて、 KL1 のような並列処理言語の方が負担が重く
なるからです。これは、階層における多くの異なるサブツリーが、データフロー
の同期機能のために、互いにインタリーブで動くためです。他の 1 つは、 KL1 
プログラムがしばしば、同じ述語を末尾再帰呼出しの形式で呼び出すゴールとし
て各々が定義された、通信プロセスの集合として書かれているためです。そのよ
うなプロセス("永久プロセス": perpetual processes と呼ばれる場合がある)は、
ほとんど終了することがないので、終了を探索することはProlog の場合に比べ、
意味がないためです。



File: KLICj.info, Node: Output of Tracer, Next: Controlling Trace, Prev: Trace Ports, Up: Tracing

トレース表示のフォーマット
--------------------------

以下に、サンプル・プログラムを示します。

     :- module main.

     main :- nrev([1,2],X), builtin:print(X).

     nrev([], R) :- R = [].
     nrev([W｜X], R) :- nrev(X, XR), append(XR, [W], R).

     append([], Y, Z)  :- Z = Y.
     append([W｜X], Y, WZ)  :- WZ = [W｜Z], append(X, Y, Z).

以下に、サンプル・プログラムの実行をすべてトレースした出力結果を示します。

     1 CALL:main:main?
     1 REDU:main:main :-
     2   0:+nrev([1,2],_4)
     3   1:+builtin:print(_4)?
     2 CALL:main:nrev([1,2],_4)?
     2 REDU:main:nrev([1,2],_4) :-
     4   0:+nrev([2],_D)
     5   1:+append(_D,[1],_4)?
     4 CALL:main:nrev([2],_D)?
     4 REDU:main:nrev([2],_D) :-
     6    0:+nrev([],_18)
     7    1:+append(_18,[2],_D)?
     6 CALL:main:nrev([],_18)?
     6 REDU:main:nrev([],[])?
     7 CALL:main:append([],[],_D)?
     7 REDU:main:append([],[2],[2])?
     5 CALL:main:append([2],[1],_4)?
     5 REDU:main:append([2],[1],[2｜_1F]) :-
     8   0:+append([],[1],_1F)?
     8 CALL:main:append([],[1],_1F)?
     8 REDU:main:append([],[1],[1])?
     3 CALL:builtin:print([2,1])?
     [2,1]
     3 REDU:builtin:print([2,1])?

このプログラムでは、中断や失敗がないので、すべてのトレース出力は、 CALL 
ポートか REDUCE ポート( トレース例では、`REDU' と出力されている)のどちら
かになります。上記の 1 行目は、初期ゴール `main:main' の CALL ポートのト
レースです。

     1 CALL:main:main?

トレースされたすべてのゴールには、ゴール間で区別するために、一意な識別子
（整数値）が与えられています。
 1 カラム目の番号 `1' は、初期ゴールの識別子です。

初期ゴールは、プログラムで定義した最初の節と一致するので、プログラム節中
で定義しているように、サブゴールにリダクションします。このリダクションは、
以下のようにトレースされます。

     1 REDU:main:main :-
     2   0:+nrev([1,2],_4)
     3   1:+builtin:print(_4)?

これは、識別子 1 を持つオリジナル・ゴール `main:main' が、2 つの新しいゴー
ルにリダクションしていることを示しています。この 2 つの新しいゴールは、 
`main:nrev([1,2],_4)' と `builtin:print(_4)' で、それぞれ識別子 2 と 3 
を持ちます。

新しいゴールの識別子 2 と 3 に続く、番号の 0 と 1 は、リダクションによっ
て生成されたサブゴールのシーケンス番号です。これらのシーケンス番号は、コ
マンドを適用するサブゴールを識別するために、トレーサ・コマンドによって使
用されます。グローバルな意味を持つ一意なゴール識別子と違って、これらのサ
ブゴール番号は、この特定のポートでしか意味を持ちません。

次に続く `:' は、サブゴールが、親ゴールの通常のサブゴールであることを意
味しています。`:' 以外にも、次に示すものがトレース表示されます。
 `*' の場合は、 `*' に続くゴールもサブゴールですが、親とは異なる優先順位
が与えられていることを意味します。優先順位は疑似プラグマ形式で表示されま
す。
 `!' の場合は、 `!' に続くゴールは、実際に親からリダクションしたサブゴー
ルではなく、このリダクションによって、具体的な値が変数に与えられたことで、
実行可能となったゴールであることを意味します。

次に `+' か `-' のどちらかが続きます。ただ実行を継続するだけの場合、 `+' 
は、サブゴールをトレースし、 `-' は、トレースしないことを意味します。こ
れは、あとの項で述べるトレース・コマンドを指定することで変更できます。上
記の例では、すべてのサブゴールに `+' が付いているので、すべてのサブゴー
ルがトレースされます。

続いて、モジュール名、コロン（:） 、そしてサブゴールの述語名が表示されま
す。サブゴールの述語のモジュール名は、その述語が親ゴールの述語と同じモジュー
ルに定義されている場合は、（:）とともに省略されます。上記の例では、サブ
ゴール `nrev' (モジュール名 `main' )は、親ゴールの `main:main' と同じモ
ジュール名なので、モジュール名は表示されません。

最後には、括弧の中にコンマ（,）で区切られた引数リストが続きます。
 nrev の第 2 引数と print の引数は `_4' です。これは、ソース・プログラム
中の `X' と対応する変数に相当します。変数は、述語節の適用ごとに新しく割
り当てられ、また、2 つ以上の変数は単一化できるので、ソース・プログラム中
のオリジナルな名前を表示することは意味がありません。このような理由で、
`_4' のような一意な名前が与えられています。

実際、この番号 `4' は、変数の物理メモリ・アドレスと関連します。そのため、
この番号は、ガーベージ・コレクションによって変更されます。しかし、ガーベー
ジ・コレクションは、それほど頻繁には行われないので、アドレス情報は、デバッ
グでは有効です。

トレースは、すべてのサブゴールと疑問符（?）を表示したあと、停止します。
ここで、次に示すトレース・コマンドを入力できます。



File: KLICj.info, Node: Controlling Trace, Next: Spying, Prev: Output of Tracer, Up: Tracing

トレース制御コマンド
--------------------

トレースは、 *leashed* された各ポートで制御します(*Note トレース・ポート
の制御: Port Control.)。トレースは、トレース対象のゴール全体や、リダクショ
ン・ポートにおいて新しく生成された各サブゴールを制御します。各述語ごとに、
ゴールをトレースするか否かのデフォルト値を設定することもできます。

* Menu:

* Goal Control::                トレース対象ゴールのトレース制御
* Subgoal Control::             新しく生成されたサブゴールのトレース制御
* Predicate Control::           述語毎のトレース・スイッチのデフォルト値の変更



File: KLICj.info, Node: Goal Control, Next: Subgoal Control, Prev: Controlling Trace, Up: Controlling Trace

トレース対象ゴールのトレース制御
................................

以下に示すコマンドは、プログラムの実行を制御するために利用します。

Continue : `c' または単に`リターン'
     ステップ実行します。
      `-' が付いたサブゴールは、ステップ・モードでもトレースしません。

Leap : `l'
     スパイ・ポイントに達するまで、トレースしないで実行を継続します。詳
     細については、*Note スパイ: Spying。

Skip : `s'
     トレース対象のゴールとすべてのサブゴールを、トレースしないで実行し
     ます。スパイ・ポイントがあっても無視します。

Abort : `a'
     プログラム全体の実行を放棄します。

これらのコマンドには、引数はありません。



File: KLICj.info, Node: Subgoal Control, Next: Predicate Control, Prev: Goal Control, Up: Controlling Trace

新しく生成されたサブゴールのトレース制御
........................................

各サブゴール( `+' や `-' で表示されている)のトレースは、以下に示すコマン
ドで変更できます。

Trace : `+' SUBGOAL_NUMBER ...
     指定したサブゴールのトレースのスイッチをオンにします。複数のサブゴー
     ル番号を指定する場合、空白で区切ります。サブゴール番号を指定しない
     場合、すべてのサブゴールがトレースされます。

No Trace : `-' SUBGOAL_NUMBER ...
     指定したサブゴールのトレースのスイッチをオフにします。複数のサブゴー
     ル番号を指定する場合、空白で区切ります。サブゴール番号を指定しない
     場合、すべてのサブゴールはトレースされません。

Toggle Trace : SUBGOAL_NUMBER ...
     指定したサブゴールのトレース・スイッチを切り替えます。トレースのス
     イッチがオンならオフに、オフならオンになります。複数のサブゴール番
     号を指定する場合、空白で区切ります。



File: KLICj.info, Node: Predicate Control, Prev: Subgoal Control, Up: Controlling Trace

述語ごとのトレース・スイッチのデフォルト値の変更
................................................

デフォルトでは、ゴールのすべてのサブゴールに対して、トレース・スイッチは、
最初の reduce ポートではオン( `+' )の状態です。このデフォルトの設定は、
この項で説明するコマンドを使えば述語ごとに変更できます。変更の結果、トレー
ス・スイッチがオフ( `-' )となった述語は、デフォルトではトレースされませ
ん。

コマンドの引数 <述語> は、以下の形式のいずれかになります。

MODULE:PREDICATE/ARITY
     明示的に、1 つの述語を指定します。例えば、 `main:nrev/2' のように指
     定します。

MODULE:PREDICATE
     引数個数に関係なく、モジュール 内のすべての述語を指定します。

MODULE:
     モジュールで定義されたすべての述語を指定します。述語名と区別するた
     め、モジュール名のあとにはコロン（:）が必要です。

PREDICATE/ARITY
     与えられた名前と引数個数を持つ現在トレース対象であるゴールの述語と
     同じモジュールで定義された述語を指定します。

PREDICATE
     与えられた名前を持つ現在トレース対象であるゴールの述語と同じモジュー
     ルで定義された述語を指定します。

与えられた述語のトレース・スイッチのデフォルトを変更するコマンドを、以下
に示します。

No Trace Default: `n' `Predicate' ...
     述語のトレース・スイッチのデフォルトをオフに設定します。引数に述語
     を指定しない場合、トレース対象ゴールの述語が指定されたものと仮定さ
     れます。

Trace Default: `t' `Predicate' ...
     述語のトレース・スイッチのデフォルトをオンに設定します。引数に述語
     を指定しない場合、トレース対象ゴールの述語が指定されたものと仮定さ
     れます。



File: KLICj.info, Node: Spying, Next: Port Control, Prev: Controlling Trace, Up: Tracing

スパイ
------

特定の述語だけをデバッグ対象にすることはよくあることです。そのような場合、
その述語のポートを "スパイ・ポイント" として指定できます。
 leap (`l') コマンドを使って、任意のスパイ・ポイントに達するまで、プログ
ラムをトレースせずに実行させることができます。詳細については、*Note トレー
ス対象ゴールのトレース制御: Goal Control。

この項で説明するコマンドは、スパイ・ポイントの設定や解除を行います。

Spy: `S' PREDICATE ...
     述語をスパイします。引数に述語が指定されない場合、トレース対象ゴー
     ルの述語をスパイします。

No Spy: `N' PREDICATE ...
     述語に設定されているスパイ・ポイントを解除します。引数に述語が指定
     されない場合、トレース対象ゴールの述語のスパイ・ポイントを解除しま
     す。



File: KLICj.info, Node: Port Control, Next: Display Control, Prev: Spying, Up: Tracing

トレース・ポートの制御
----------------------

4 つのトレース・ポートを使用可能状態( enabled )にしたり、使用禁止状態(
disabled )にしたりできます。使用禁止状態になったポートはトレースされませ
ん。

さらに各ポートに対して、停止状態になってコマンド入力を待つか否かを指定で
きます。実行を停止して、コマンドを待つポートのことを "leashed" と呼びま
す。使用可能状態で leashed されていないポートの場合、トレース結果の出力
表示後すぐに continue コマンド(キャリッジ・リターン)が入力されたように、
実行が継続されます。スパイ対象の述語の場合、 unleashed なポートも 
leashed になります。

この項で説明するコマンドは、そのようなポートの属性を制御するために使用さ
れます。これらのコマンドでは、以下に示す方法で引数にポート名を指定します。

Call:
     `c', `call'
Reduce:
     `r', `redu', `reduce'
Suspend:
     `s', `susp', `suspend'
Fail:
     `f', `fail'
All ports:
     `a', `all'

ポートを制御するコマンドを以下に示します。

Enable Port: `E' PORT ...
     指定されたポート(群)を使用可能状態にします。

Disable Port: `D' PORT ...
     指定されたポート(群)を使用禁止状態にします。

Leash Port: `L' PORT ...
     指定されたポート(群)を leashed にします。

Unleash Port: `U' PORT ...
     指定されたポート(群)を unleashed にします。



File: KLICj.info, Node: Display Control, Next: Dumping Goals, Prev: Port Control, Up: Tracing

表示を制御するコマンド
----------------------

トレース対象ゴールの完全情報が常に必要であるとは限りません。逆にそういっ
た過剰な完全情報がプログラム動作の理解を妨げる場合さえあります。そういっ
た場合のために、トレース・ポートで表示される情報量を制御するコマンドが、
提供されています。

表示量は、以下に示すオプションの組合せで制御されます。

   * 表示の深さ制限：深さ制限以下の引数構造は、次に示す省略形で表示します。

          f(a,b,c,d,e)    ==>    f(..)
          [a,b,c,d,e]     ==>    [..]

   * 表示の長さ制限：長さ制限を超えた引数リストの構造や文字列は、次に示す省略形で表示します。

          f(a,b,c,d,e)    ==>    f(a,b,c,..)
          [a,b,c,d,e]     ==>    [a,b,c,..]
          "abcde"         ==>    "abc.."

   * サブタームの表示指定 : 指定されたトレース対象ゴールの特定の部分だけを表示します。

以下に示すコマンドは、オプション制御のために使用できます。

Set Print Depth: `pd' DEPTH
     データ構造の表示の深さ制限に DEPTH を設定します。引数なしの場合、現
     在の深さ制限値で表示します。

Set Print Length: `pl' LENGTH
     データ構造の表示の長さ制限に LENGTH を設定します。引数なしの場合、
     現在の長さ制限値で表示します。

Toggle Verbose Print: `pv'
     詳細表示モードのスイッチを切り替えます。詳細表示モードでは、ゴール
     の実行を中断している変数を表示する際に、そのゴールも一緒に表示しま
     す。

Set Subterm: `^' N
Reset Subterm:`^'

     トレース対象ゴールの N 番目のサブタームを表示します。
      N に 0 が指定された場合、サブタームは 1 レベル上がります。
      N が省略された場合、サブタームの表示を解除します。リスト構造の場合、 
     1 は car 、 2 は cdr を意味します。

     このコマンド実行中は、トレース対象ゴールのサブタームだけが表示され
     ます。表示されているサブタームの前には、タームのどの部分が表示され
     ているのかを示す位置情報が表示されます。以下に例を示します。

            10 CALL: foo:bar(f(a,g(..),[..]))? ^1
            10 CALL: ^1 f(a,g(b,c),[d,e])? ^2
            10 CALL: ^1^2 g(b,c)? ^0
            10 CALL: ^1 f(a,g(b,c),[d,e])? ^3
            10 CALL: ^1^3 [d,e]? ^2
            10 CALL: ^1^3^2 [e]? ^
            10 CALL: foo:bar(f(a,g(..),[..]))?  REDUCE ポートでは、サブ
     タームを指定していると、リダクションで生成されたサブゴールは、表示
     されません。指定した親ゴールのサブタームだけが表示されます。現在の
     版では、ベクタ要素はサブタームとして指定できません。

深さ制限と長さ制限の初期設定値は、それぞれ 3 と 7 です。詳細表示モードの
スイッチは、最初はオフに設定されています。



File: KLICj.info, Node: Dumping Goals, Next: Misc Trace Commands, Prev: Display Control, Up: Tracing

ゴールのダンプ
--------------

最後の手段として、システム中のすべてのゴールをダンプすることが望ましい場
合があります。ダンプする場合のコマンドを以下に示します。

レディ・キューのダンプ : `Q'
     レディ・キュー(ゴール・プール)中のすべてのゴールを、優先順位ととも
     に表示します。

中断(待ち状態)ゴールのダンプ : `W'
     システム中のすべての中断ゴールを、優先順位とともに表示します。



File: KLICj.info, Node: Misc Trace Commands, Next: Perpetual Suspension, Prev: Dumping Goals, Up: Tracing

その他のコマンド
----------------

ステータスの問合せ : `='
     トレーサのステータス情報を、以下のように表示します。
             port: Call Susp Redu Fail
          enabled:  +    +    +    +
          leashed:  +    +    +    +
          print terse; depth = 3; length = 7

モジュール表示 : `lm'
     現在実行しているプログラムの、すべてのモジュールを表示します。

述語表示 : `lp'
     現在実行しているプログラムの、すべての述語とデフォルトのトレース状
     態を表示します。

キュー表示 : `Q'
     レディ・キュー(ゴール・プール)の内容を表示します。

ヘルプ : `?'または`h'
     現在のポートで利用できる、すべてのコマンドとその簡略説明を表示しま
     す。



File: KLICj.info, Node: Perpetual Suspension, Prev: Misc Trace Commands, Up: Tracing

永久中断の探索
--------------

あるゴールが、他のどのゴールからも具体化されない変数の具体化を待ち続ける
場合、そのゴールは永久に先に進めなくなります。このような状態を、"永久中
断"( perpetual suspention )と呼びます。永久中断は、 KLIC のガーベージ・
コレクタが見つけ出すので、プログラム実行中に、ガーベージ・コレクションが
発生すると、永久中断が見つけ出されることがあります。

システムは中断ゴールの数を管理しています。実行できるゴールが全くない状態
で中断ゴールが残っている場合、システムは永久中断を見つけ出すためにガーベー
ジ・コレクションを試みます。

永久中断は、以下のように報告されます。

     !!! Perpetual Suspention Detected !!!
        3 PSUS: MODULE:PREDICATE(ARGS...)? 

ここでは、 FAIL ポートと同じコマンド群が利用できます。



File: KLICj.info, Node: Install, Next: Distributed KLIC, Prev: Tracing, Up: Using KLIC

インストール
============

KLIC のインストールは、比較的簡単に行えます。

ホスト依存とユーザの選択に基づくカスタマイズは、配布された構成スクリプト
を実行させて行います。その後、 `make all' でシステム全体をコンパイルして
ください。次に、 `make tests' の実行によって、システムが問題なくコンパイ
ルされたことが確認できます。続いて、 `make install' でシステムのインストー
ルができます。

* Menu:

* Configuration::               コンフィギュレーション
* Make All::                    KLIC システムのコンパイル
* Make Tests::                  コンパイル結果のテスト
* Make Install::                オブジェクトのインストール
* Make Distclean::              インストールディレクトリのクリーン・アップ
* Troubles::                    うまく行かない場合



File: KLICj.info, Node: Configuration, Next: Make All, Prev: Install, Up: Install

コンフィギュレーション
----------------------

KLIC のインストールで最初に行うことは、ホスト・コンピュータ・システムと、
ユーザの選択に依存した KLIC システムを構成することです。

配布物のルート・ディレクトリ(以下、 ROOT と呼びます)に進んでください。そ
の後、 `./Configure' コマンドで構成スクリプトを実行してください。スクリ
プトが、利用できるソフトウェア・ツールを、システムから探索して、選択の問
合せをしてきます。

一部の BSD 4.2 をベースとする Unix システムでは、この構成スクリプトの構
文の一部が、デフォルトで用意されたシェルでは実行できないことがあります。
その場合は、新しいシェル(GNU `bash' など)を入手して、次のようにスクリプ
トを実行して下さい。

     % bash Configure

KLIC システムを前に構成したことがあり、同じディレクトリで再構成を行う場
合は、前回指定した値をデフォルト値にするかどうか、問い合わせてきます。

次の(初めてシステムを構成する場合は最初の)問い合わせは、KLIC の並列版を
構成するか否かというものです。
逐次システムだけをインストールしたい場合は、 `no' と答えてください。
並列版システムの構成の詳細については、
*Note 分散 KLIC: Distributed KLIC ,
*Note 共有メモリ KLIC: Shared-Memory KLIC。

構成スクリプトは、以下の 3 個のファイルを作成します。

     `ROOT/Makefile'
     `ROOT/include/klic/config.h'
     `ROOT/config.sh'

最後のファイルは、システム再構成に備えて今回指定したオプションを保存しま
す。

構成スクリプトは、インストール手続きで使用される並列機能(parallelism)に
ついて問い合わせてきます。このとき、システムを負荷の軽いマルチプロセッサ・
システムにインストール中であれば、ここでゼロ以外の並列機能を指定できます。
 `make' の並列実行機能を使用しては*なりません*。



File: KLICj.info, Node: Make All, Next: Make Tests, Prev: Configuration, Up: Install

KLIC システムのコンパイル
-------------------------

システムの構成後は、 `make all' と入力して、 KL1 から C へのコンパイラと、
実行時ライブラリを含む KLIC システム全体をコンパイルしてください。



File: KLICj.info, Node: Make Tests, Next: Make Install, Prev: Make All, Up: Install

コンパイル結果のテスト
----------------------

システム全体のコンパイルが終了した後は、コンパイルが問題なく終了したか否
かをテストすることをお勧めします。テストする場合には、提供されたルート・
ディレクトリ内(そのサブディレクトリ `test' ではありません)で `make test' 
と入力してください。何本かの KL1 テスト・プログラムがコンパイル・実行さ
れて、出力結果と予想結果が比較されます。



File: KLICj.info, Node: Make Install, Next: Make Distclean, Prev: Make Tests, Up: Install

オブジェクトのインストール
--------------------------

コンパイルが終了したあと、 `make install' と入力すると、コンパイラ、ヘッ
ダ・ファイル、および実行時ライブラリが、コンフィギュレーションで指定した
ディレクトリにインストールされます(*Note コンフィギュレーション:
Configuration.)。



File: KLICj.info, Node: Make Distclean, Next: Troubles, Prev: Make Install, Up: Install

インストール・ディレクトリのクリーン・アップ
--------------------------------------------

インストールが終了したあと、 `make distclean' と入力すると、配布物中に含
まれて *いない* すべてのファイルが削除されます。

一般ユーザは、`make realclean' を試しては *なりません*。このコマンドは、 
KL1 から生成された C プログラムのソース・ファイルを削除します。削除した 
C プログラムのソース・ファイルを再生成するには、既に動いている KL1 から 
C へのコンパイラが必要です。



File: KLICj.info, Node: Troubles, Prev: Make Distclean, Up: Install

うまく行かない場合
------------------

構成ミスのために、インストール手続きがうまく行かない場合は、コンフィギュ
レーションからやり直した方がよいでしょう(*Note コンフィギュレーション:
Configuration.)。構成スクリプトは、コンフィギュレーションのやり直しのた
めに、システムをクリーン・アップするか否かを問い合わせてきます。そのとき
には yes と答えてください。

Makefile に書かれる依存ルールは、`make' のいくつかのバージョンで提供され
る make の並列機能を使用する場合には適切ではありません。アトムとファンク
タのデータベースが単調に増大しているという事実に依存しているので、それら
のデータベースに依存するようには書けません。代わりに、コンパイラ・ドライ
バ `klic' の並列実行機能を使用してください。使用する並列機能は、コンフィ
ギュレーションの段階で指定します(*Note コンフィギュレーション:
Configuration.)。

配布されたコードに問題があると思われる場合は、以下に示すアドレスまでご報
告ください。

     `klic-bugs@icot.or.jp'

その際、ホスト・システム(ハードウェアとオペレーティング・システム)と構成
(トップレベルの `Makefile' と `include/klic/config.h' ファイル)に関する
情報があると、問題分析に役立ちます。



File: KLICj.info, Node: Distributed KLIC, Next: Shared-Memory KLIC, Prev: Install, Up: Using KLIC

分散 KLIC
=========

KLIC の分散並列実装版も、配布される KLIC に含まれています。この分散実装
は PVM3.3 に基づいています。
 MPI 等の並列処理ライブラリや、システム固有のプロセス間通信ライブラリに
基づく実装も行われていますが、この配布版にはまだ統合されていません。

PVM に基づいていますが、現在の版では異種構成をサポートしていません。複数
のアーキテクチャを持つプロセッサで構成されるシステムや、異なるオペレーティ
ング・システムを動かすシステムでは機能しません。現時点では、異種システム
をサポートする計画は全くありません。

* Menu:

* Installation of Distributed KLIC::        分散 KLIC のインストール
* Compiling Programs for Distributed KLIC:: 分散 KLIC 向けプログラムのコンパイル
* Running Programs of Distributed KLIC::    分散 KLIC のプログラム実行



File: KLICj.info, Node: Installation of Distributed KLIC, Next: Compiling Programs for Distributed KLIC, Prev: Distributed KLIC, Up: Distributed KLIC

分散 KLIC のインストール
------------------------

分散 KLIC の PVM 版をインストールする場合、まず並列版を構成するか否かを
構成スクリプトが最初に問い合わせてくるので、
 yes と答えてください。次に分散 KLIC を構成するか否かを、問い合わせてく
るので、これにも yes と答えてください。そのあと、 PVM が利用できる場合は、 
PVM システムのインストール先のディレクトリや、使用する PVM ライブラリな
どについて、問い合わせてきます。

問合せの内容を、以下に示します。

   *  PVM システムのルート・ディレクトリ
   * システムのアーキテクチャのキーワード(例えば、 `SUNMP' など)
   * PVM ライブラリの名前(例えば、 `pvm3' など)

現在の版では、デーモンプロセスを使用しない PVM の実装には、問題がありま
す。例えば、 Solaris2 が動いている共有メモリ・マルチプロセッサの Sparc 
システムの場合、ライブラリの `pvm3' が機能しません。プロセス間通信には、
共有メモリの代わりにソケットを使う `pvm3s' を使用してください。

インストール手続きの残りの部分は、分散 KLIC をインストールしない場合の手
続きと同じです。

分散処理のオプション( `-dp' )が、コンパイル時に指定されていない場合、分
散 KLIC システムは、逐次版と全く同じように動作します。



File: KLICj.info, Node: Compiling Programs for Distributed KLIC, Next: Running Programs of Distributed KLIC, Prev: Installation of Distributed KLIC, Up: Distributed KLIC

分散 KLIC 向けプログラムのコンパイル
------------------------------------

コンパイル手続きは、以下に示すオプションが利用できる他は、逐次版とほぼ同
じです。

-dp
     分散 KLIC システムを用いたコンパイルを指定します。このオプションの
     指定がない場合、コンパイルされるオブジェクト・コードは、逐次処理で
     しか動きません。



File: KLICj.info, Node: Running Programs of Distributed KLIC, Prev: Compiling Programs for Distributed KLIC, Up: Distributed KLIC

分散 KLIC のプログラム実行
--------------------------

* Menu:

* Setting Up PVM::                          PVM のセット・アップ
* Runtime Options for Distributed KLIC::    分散 KLIC の実行時オプション
* Known Bugs of Distributed KLIC::          分散 KLIC の既知のバグ



File: KLICj.info, Node: Setting Up PVM, Next: Runtime Options for Distributed KLIC, Prev: Running Programs of Distributed KLIC, Up: Running Programs of Distributed KLIC

PVM のセット・アップ
....................

分散実行用にコンパイルされたプログラムを実行する前に、 PVM システムがシ
ステム上で稼働している必要があります。以下に示すセット・アップが必要です。

   * 次の環境変数を設定してください。

     PVM_ROOT
          システムにインストールした PVM システムのルート・ディレクトリ

     PVM_ARCH
          システムのアーキテクチャを指定するキーワード


     これらは、分散 KLIC システムをインストールした時に指定したものと同
     じものを指定してください。

   *  PVM のデーモンを開始してください。デーモンは、 PVM コンソールを起
     動することで開始できます。
      PVM コンソールは、 `$PVM_ROOT/lib/$PVM_ARCH/pvm' に存在します。こ
     のコンソール用のウィンドウがあると便利です。

他のパラメタの設定と PVM コンソールの操作の詳細については、専用のマニュ
アルをご覧ください。



File: KLICj.info, Node: Runtime Options for Distributed KLIC, Next: Known Bugs of Distributed KLIC, Prev: Setting Up PVM, Up: Running Programs of Distributed KLIC

分散 KLIC の実行時オプション
............................

分散 KLIC システムでプログラムを動かす場合、逐次版で利用できるオプション
に加えて、以下のオプションが利用できます。

-p N
     プログラムを動かすための疑似プロセッサ( Unix プロセス)の数を指定し
     ます。
      klic 2.0 版ではパラメータが -dp から -p に変更になっています.

-e
     バッチ転送モードに切り替えます。通常、 KLIC は要求時にプロセッサ間
     でデータ構造を転送します。ネストしたデータ構造は通常、1 度に 1 レベ
     ルずつ転送します。バッチ転送では、ネストしたデータ構造を 1 度に転送
     します。これは、いくつかのプログラムに対して、より効率的に実行しま
     す。しかし、他のプログラムの性能を劣化させることもあります。

-E LEVEL
     ネストしたデータ構造について、何レベルまで一度に送信するかを指定し
     ます。

-I MICROSEC
     プロセッサ間通信のポーリング間隔を指定します。このポーリングが必要
     かどうか、またどのような値が適切であるかは、ホストシステムと物理通
     信層の実装に依存します。多くの場合は、デフォルト値である 10000 が適
     切です。

-n
     実行時の統計情報を表示します。

-notimer
     タイマ駆動の通信ポーリングを行いません。このポーリングが必須かどう
     かは、物理通信層の実装に依存します。

-relsp
     疑似プロセッサプロセスを生成する時の実行ファイルを、相対パスで探し
     ます。

-S
     通信パケットの受信側プロセスに対し、シグナル送信による通知を行いま
     せん。実装によっては、この指定によりシグナル送信のオーバヘッドが減
     るため、実行速度が向上する場合があります。



File: KLICj.info, Node: Known Bugs of Distributed KLIC, Prev: Runtime Options for Distributed KLIC, Up: Running Programs of Distributed KLIC

分散 KLIC の既知のバグ
......................

   * 新しく登録されたアトムとファンクタは、プログラムの実行中に、正常に
     処理されないことがあります。

   * スパイの指定(*Note スパイ: Spying.)は、指定した計算ノードの内部だけ
     に効果があります。



File: KLICj.info, Node: Shared-Memory KLIC, Prev: Distributed KLIC, Up: Using KLIC

共有メモリ KLIC
===============

KLIC の共有メモリ並列実装版も、配布される KLIC に含まれています。この実
装は、ハードウェア、 OS 、 C コンパイラの各々に依存する部分から成ります。
このバージョンでは、SunOS 5.3 が動作している Sparc ベースのシステム、お
よび DEC OSF/1 が動作している Alpha ベースのシステムに対応しています。コ
ンパイルには、 Gnu CC が必要です。

* Menu:

* Installation of Shared-Memory KLIC::          共有メモリ KLIC のインストール
* Compiling Programs for Shared-Memory KLIC::   共有メモリ KLIC 向けプログラムのコンパイル
* Running Programs of Shared-Memory KLIC::      共有メモリ KLIC のプログラム実行



File: KLICj.info, Node: Installation of Shared-Memory KLIC, Next: Compiling Programs for Shared-Memory KLIC, Prev: Shared-Memory KLIC, Up: Shared-Memory KLIC

共有メモリ KLIC のインストール
------------------------------

共有メモリ版の KLIC をインストールする場合、まず共有メモリ KLIC を構成す
るか否かを問い合わせてくるので、
 yes と答えてください

インストール手続きの残りの部分は、共有メモリ KLIC をインストールしない場
合の手続きと同じです。

共有メモリ並列処理のオプション( `-shm' )が、コンパイル時に指定されていな
い場合、共有メモリ KLIC システムは、逐次版と全く同じように動作します。



File: KLICj.info, Node: Compiling Programs for Shared-Memory KLIC, Next: Running Programs of Shared-Memory KLIC, Prev: Installation of Shared-Memory KLIC, Up: Shared-Memory KLIC

共有メモリ KLIC 向けプログラムのコンパイル
------------------------------------------

コンパイル手続きは、以下に示すオプションが利用できる他は、逐次版とほぼ同
じです。

-shm
     共有メモリ KLIC システムを用いたコンパイルを指定します。このオプショ
     ンの指定がない場合、コンパイルされるオブジェクト・コードは、逐次処
     理でしか動きません。



File: KLICj.info, Node: Running Programs of Shared-Memory KLIC, Prev: Compiling Programs for Shared-Memory KLIC, Up: Shared-Memory KLIC

共有メモリ KLIC のプログラム実行
--------------------------------

* Menu:

* Runtime Options for Shared-Memory KLIC::  共有メモリ KLIC の実行時オプション
* Known Bugs of Shared-Memory KLIC::        共有メモリ KLIC の既知のバグ



File: KLICj.info, Node: Runtime Options for Shared-Memory KLIC, Next: Known Bugs of Shared-Memory KLIC, Prev: Running Programs of Shared-Memory KLIC, Up: Running Programs of Shared-Memory KLIC

共有メモリ KLIC の実行時オプション
..................................

共有メモリ KLIC システムでプログラムを動かす場合、逐次版で利用できるオプ
ションに加えて、以下のオプションが利用できます。

-p N
     プログラムを動かすための疑似プロセッサ( Unix プロセス)の数を指定し
     ます。

-D
     子である疑似プロセッサのプロセス番号を報告します。低レベルのデバッ
     グで便利かもしれません。

-S SIZE
     共有ヒープ領域の大きさを指定します。現在の実装では、共有ヒープ領域
     は初期化の際に確保され、以後拡張されることはありません。



File: KLICj.info, Node: Known Bugs of Shared-Memory KLIC, Prev: Runtime Options for Shared-Memory KLIC, Up: Running Programs of Shared-Memory KLIC

共有メモリ KLIC の既知のバグ
............................

   * トレーサが正しく動かないことがあります。



File: KLICj.info, Node: Type Index, Next: Predicate Index, Prev: Using KLIC, Up: Top

データ型索引
************

* Menu:

* 整数[せいすう]:               Integers.               4.
* マージャ[まーじゃ]:           Merging.                57.
* モジュール[もじゅーる]:       Module Type.            4.
* アトム[あとむ]:               Symbolic Atoms.         4.
* 浮動小数点数[ふどうしょうすうてんすう]: Floating Points.  4.
* 文字列[もじれつ]:             Strings.                4.
* リスト[りすと]:               Lists.                  4.
* 述語[じゅつご]:               Predicate Type.         4.
* ファンクタ[ふぁんくた]:       Functors.               4.
* ベクタ[べくた]:               Vectors.                4.



File: KLICj.info, Node: Predicate Index, Next: Module Index, Prev: Type Index, Up: Top

述語、メソッド、メッセージ名索引
********************************

* Menu:

* =.. on 述語:                  Functor Operation.      46.
* > on builtin:                 Integer Comp.           12.
* < on builtin:                 Integer Comp.           17.
* = on builtin:                 Unification.            10.
* = on builtin:                 Unification.            6.
* @< on builtin:                Comparison and Hashing.  40.
* @> on builtin:                Comparison and Hashing.  43.
* \= on builtin:                Comparison and Hashing.  47.
* $> on builtin:                Floating Comp.          12.
* $< on builtin:                Floating Comp.          17.
* := on builtin:                Integer Arith.          7.
* := on builtin:                Integer Arith.          8.
* >= on builtin:                Integer Comp.           13.
* =< on builtin:                Integer Comp.           16.
* @=< on builtin:               Comparison and Hashing.  41.
* @>= on builtin:               Comparison and Hashing.  42.
* $:= on builtin:               Floating Arith.         7.
* $>= on builtin:               Floating Comp.          13.
* $=< on builtin:               Floating Comp.          16.
* =:= on builtin:               Integer Comp.           14.
* =\= on builtin:               Integer Comp.           15.
* $=:= on builtin:              Floating Comp.          14.
* $=\= on builtin:              Floating Comp.          15.
* accept on バウンド・ソケット: Sockets.                36.
* access on unix ストリーム:    Files & Dirs.           27.
* acos on float:                Floating Arith.         67.
* add on float:                 Floating Arith.         58.
* add on timer:                 Timer.                  34.
* addop on Prolog 風の I/O :    Common Msgs (Prolog style).  18.
* append_open on klicio ストリーム: Opening Prolog I/O.  26.
* append_open on unix ストリーム: I/O Opening.          29.
* apply on predicate:           Predicate Type.         44.
* arg on builtin:               Functor Operation.      27.
* arg on builtin:               Functor Operation.      28.
* argc on predicate:            Predicate Interface.    10.
* argv on unix:                 Predicate Interface.    15.
* arity on predicate:           Predicate Type.         40.
* arity on predicate:           Predicate Type.         41.
* asin on float:                Floating Arith.         66.
* atan on float:                Floating Arith.         68.
* atom on builtin:              Symbolic Atom Operation.  9.
* atomic on builtin:            Atomic Data.            18.
* atom_number on atom_table:    Symbolic Atom Operation.  21.
* bind on unix ストリーム:      Sockets.                25.
* call on predicate:            Predicate Type.         49.
* cd on unix ストリーム:        Files & Dirs.           10.
* ceil on float:                Floating Arith.         75.
* chmod on unix ストリーム:     Files & Dirs.           42.
* compare on builtin:           Comparison and Hashing.  6.
* compare on timer:             Timer.                  38.
* connect on unix ストリーム:   Sockets.                10.
* cos on float:                 Floating Arith.         64.
* cosn on float:                Floating Arith.         70.
* current_node on builtin:      Execution Status.       11.
* current_priority on builtin:  Execution Status.       7.
* divide on float:              Floating Arith.         61.
* element on string:            Predicates and Methods.  17.
* element on string:            Predicates on Strings.  20.
* element on string:            Predicates on Strings.  21.
* element on vector:            Predicates on Vectors.  13.
* element on vector:            Predicates on Vectors.  14.
* element_size on string:       Predicates on Strings.  17.
* equal on float:               Floating Comp.          35.
* exit on unix:                 Predicate Interface.    19.
* exp on float:                 Floating Arith.         72.
* fclose on C 風の I/O :        Common Msgs (C style).  33.
* fclose on Prolog 風の I/O :   Common Msgs (Prolog style).  13.
* feof on C 風の I/O :          Common Msgs (C style).  10.
* feof on Prolog 風の I/O :     Common Msgs (Prolog style).  10.
* fflush on C 風の I/O :        Output Msgs (C style).  27.
* fflush on Prolog 風の I/O :   Output Msgs (Prolog style).  32.
* float on builtin:             Floating Points.        12.
* float on float:               Floating Points.        11.
* floor on float:               Floating Arith.         76.
* fork on unix ストリーム:      Misc Unix Messages.     29.
* fork_with_pipes on unix ストリーム: Misc Unix Messages.  35.
* fread on C 風の I/O :         Input Msgs (C style).   15.
* fread on Prolog 風の I/O :    Input Msgs (Prolog style).  29.
* fseek on C 風の I/O :         Common Msgs (C style).  15.
* fseek on Prolog 風の I/O :    Common Msgs (Prolog style).  11.
* ftell on C 風の I/O :         Common Msgs (C style).  26.
* ftell on Prolog 風の I/O :    Common Msgs (Prolog style).  12.
* functor on builtin:           Functor Operation.      14.
* functor on builtin:           Functor Operation.      15.
* fwrite on C 風の I/O :        Output Msgs (C style).  15.
* fwrite on C 風の I/O :        Output Msgs (C style).  20.
* fwrite on Prolog 風の I/O :   Output Msgs (Prolog style).  30.
* fwrite on Prolog 風の I/O :   Output Msgs (Prolog style).  31.
* gc on system_control:         System Control.         21.
* get_atom_name on atom_table:  Symbolic Atom Operation.  31.
* get_atom_string on atom_table: Symbolic Atom Operation.  24.
* getc on C 風の I/O :          Input Msgs (C style).   8.
* getc on Prolog 風の I/O :     Input Msgs (Prolog style).  27.
* getenv on unix ストリーム:    Misc Unix Messages.     13.
* gett on Prolog 風の I/O :     Input Msgs (Prolog style).  7.
* get_time_of_day on timer:     Timer.                  21.
* getwt on Prolog 風の I/O :    Input Msgs (Prolog style).  13.
* greater_than on float:        Floating Comp.          34.
* hash on builtin:              Comparison and Hashing.  59.
* instantiate_after on timer:   Timer.                  44.
* instantiate_at on timer:      Timer.                  43.
* instantiate_every on timer:   Timer.                  53.
* integer on builtin:           Integers.               11.
* intern on atom_table:         Symbolic Atom Operation.  27.
* join on string:               Predicates on Strings.  53.
* join on vector:               Predicates on Vectors.  41.
* kill on unix ストリーム:      Misc Unix Messages.     24.
* klicio on predicate:          Opening Prolog I/O.     7.
* less_than on float:           Floating Comp.          31.
* less_than on string:          Predicates on Strings.  27.
* linecount on C 風の I/O :     Input Msgs (C style).   23.
* linecount on Prolog 風の I/O : Input Msgs (Prolog style).  30.
* list on builtin:              Lists.                  18.
* log on float:                 Floating Arith.         73.
* make_atom on atom_table:      Symbolic Atom Operation.  17.
* mktemp on unix ストリーム:    Files & Dirs.           20.
* module on module:             Module Type.            16.
* module on predicate:          Predicate Type.         54.
* multiply on float:            Floating Arith.         60.
* name on module:               Module Type.            20.
* name on predicate:            Predicate Type.         58.
* new on オブジェクト生成:      Creating Floats.        10.
* new on merge:                 Merging.                57.
* new on module:                Module Type.            10.
* new on predicate:             Predicate Type.         30.
* new on random_numbers:        Random Numbers.         11.
* new on random_numbers:        Random Numbers.         12.
* new on string:                Creating Strings.       10.
* new on vector:                Creating Vectors.       10.
* new_functor on builtin:       Functor Operation.      34.
* new_string on builtin:        Creating Strings.       11.
* new_vector on builtin:        Creating Vectors.       11.
* nl on Prolog 風の I/O :       Output Msgs (Prolog style).  45.
* not_equal on float:           Floating Comp.          36.
* not_greater_than on float:    Floating Comp.          32.
* not_less_than on float:       Floating Comp.          33.
* not_less_than on string:      Predicates on Strings.  31.
* NUMBER on C 風の I/O :        Output Msgs (C style).  11.
* NUMBER on Prolog 風の I/O :   Output Msgs (Prolog style).  29.
* postmortem on system_control: System Control.         9.
* pow on float:                 Floating Arith.         62.
* predicate on predicate:       Predicate Type.         37.
* putc on C 風の I/O :          Output Msgs (C style).  8.
* putc on C 風の入出力:         Messages.               19.
* putc on Prolog 風の I/O :     Output Msgs (Prolog style).  28.
* putenv on unix ストリーム:    Misc Unix Messages.     18.
* putt on Prolog 風の I/O :     Output Msgs (Prolog style).  7.
* puttq on Prolog 風の I/O :    Output Msgs (Prolog style).  8.
* putwt on Prolog 風の I/O :    Output Msgs (Prolog style).  9.
* putwtq on Prolog 風の I/O :   Output Msgs (Prolog style).  10.
* read_open on klicio ストリーム: Opening Prolog I/O.   24.
* read_open on unix ストリーム: I/O Opening.            27.
* rmop on Prolog 風の I/O :     Common Msgs (Prolog style).  21.
* search_character on builtin:  Predicates on Strings.  58.
* search_character on string:   Predicates on Strings.  57.
* setarg on builtin:            Functor Operation.      39.
* setarg on builtin:            Functor Operation.      40.
* set_element on string:        Predicates on Strings.  40.
* set_element on vector:        Predicates on Vectors.  20.
* set_element on vector:        Predicates on Vectors.  27.
* set_string_element on builtin: Predicates on Strings.  41.
* set_vector_element on builtin: Predicates on Vectors.  21.
* set_vector_element on builtin: Predicates on Vectors.  28.
* signal_stream on unix ストリーム: Signals.            9.
* sin on float:                 Floating Arith.         63.
* sinh on float:                Floating Arith.         69.
* size on string:               Predicates on Strings.  14.
* size on vector:               Predicates on Vectors.  8.
* split on string:              Predicates on Strings.  47.
* split on vector:              Predicates on Vectors.  35.
* sqrt on float:                Floating Arith.         74.
* stderr on klicio ストリーム:  Opening Prolog I/O.     23.
* stderr on unix ストリーム:    I/O Opening.            21.
* stdin on klicio ストリーム:   Opening Prolog I/O.     21.
* stdin on unix ストリーム:     I/O Opening.            19.
* stdout on klicio ストリーム:  Opening Prolog I/O.     22.
* stdout on unix ストリーム:    I/O Opening.            20.
* string on builtin:            Predicates on Strings.  36.
* string on builtin:            Predicates on Strings.  9.
* string on string:             Predicates on Strings.  35.
* string on string:             Predicates on Strings.  7.
* string on string:             Predicates on Strings.  8.
* string_element on builtin:    Predicates and Methods.  16.
* string_element on builtin:    Predicates on Strings.  22.
* string_element on builtin:    Predicates on Strings.  23.
* string_less_than on builtin:  Predicates on Strings.  28.
* string_not_less_than on builtin: Predicates on Strings.  32.
* sub on timer:                 Timer.                  35.
* subtract on float:            Floating Arith.         59.
* sync on C 風の I/O :          Common Msgs (C style).  38.
* sync on Prolog 風の I/O :     Common Msgs (Prolog style).  14.
* system on unix ストリーム:    Misc Unix Messages.     9.
* tan on float:                 Floating Arith.         65.
* tanh on float:                Floating Arith.         71.
* times on unix:                Predicate Interface.    22.
* umask on unix ストリーム:     Files & Dirs.           48.
* umask on unix ストリーム:     Files & Dirs.           49.
* unbound on builtin:           Debugging.              7.
* ungetc on C 風の I/O :        Input Msgs (C style).   12.
* ungetc on Prolog 風の I/O :   Input Msgs (Prolog style).  28.
* unix on unix:                 Unix Stream.            10.
* unlink on unix ストリーム:    Files & Dirs.           15.
* unwrap on 変換:               Wrapped Terms.          45.
* update_open on klicio ストリーム: Opening Prolog I/O.  27.
* update_open on unix ストリーム: I/O Opening.          30.
* vector on builtin:            Predicates on Vectors.  9.
* vector on vector:             Predicates on Vectors.  7.
* vector_element on builtin:    Predicates on Vectors.  15.
* vector_element on builtin:    Predicates on Vectors.  16.
* wait on builtin:              Synchronization.        6.
* wrap on variable:             Wrapped Terms.          55.
* write_open on klicio ストリーム: Opening Prolog I/O.  25.
* write_open on unix ストリーム: I/O Opening.           28.



File: KLICj.info, Node: Module Index, Next: Concepts, Prev: Predicate Index, Up: Top

モジュール名索引
****************

* Menu:

* `atom_table':                 Symbolic Atom Operation.  14.
* `ジェネリック' (pseudo module): Generic Objects.      4.
* `functor_table':              Functor Operation.      7.
* `klicio':                     Opening Prolog I/O.     4.
* `system_control':             System Control.         7.
* `unix':                       Unix.                   4.



File: KLICj.info, Node: Concepts, Prev: Module Index, Up: Top

索引
****

* Menu:

* accumulator:                  Usage of Paired Arguments.  7.
* alternatively:                Alternatively.          4.
* 三角関数[さんかくかんすう]:   Floating Arith.         27.
* 整数演算[せいすうえんざん]:   Integer Arith.          4.
* 整数[せいすう]:               Integers.               4.
* 整数比較[せいすうひかく]:     Integer Comp.           4.
* 整数からの浮動小数点変換[せいすうからのふどうしょうすうてんへんかん]: Creating Floats.  4.
* 整数の演算[せいすうのえんざん]: Integer Arith.        4.
* 整数の比較[せいすうのひかく]: Integer Comp.           4.
* 整数の浮動小数点への変換[せいすうのふどうしょうすうてんへのへんかん]: Creating Floats.  4.
* 整数の浮動小数点への変換[せいすうのふどうしょうすうてんへのへんかん]: Creating Floats.  4.
* 引数モード[ひきすうもーど]:   Argument Modes.         4.
* 引数対[ひきすうつい]:         Argument Pair Notation.  4.
* 引数対[ひきすうつい]:         Paired Arguments.       4.
* 演算子順位文法[えんざんしじゅんいぶんぽう]: Prolog I/O.  4.
* 改訂[かいてい]:               Macros for Paired Arguments.  4.
* 割り込み[わりこみ]:           Signals.                4.
* コンス・セル[こんすせる]:     Lists.                  4.
* コマンド行引数[こまんどぎょうひきすう]: Predicate Interface.  4.
* コンパイル[こんぱいる]:       Compiling.              4.
* コンフィギュレーション[こんふぃぐれーしょん]: Configuration.  4.
* コンフィギュレーション[こんふぃぎゅれーしょん]: Installation of Distributed KLIC.  4.
* コンフィギュレーション[こんふぃぎゅれーしょん]: Installation of Shared-Memory KLIC.  4.
* コピーライト[こぴーらいと]:   Copying.                4.
* 丸め[まるめ]:                 Floating Arith.         45.
* 環境変数[かんきょうへんすう]: Misc Unix Messages.     4.
* ゴール[ごーる]:               Goals.                  4.
* ゴール・プール[ごーるぷーる]: Dumping Goals.          4.
* 時間[じかん]:                 Timer.                  4.
* 正弦[せいげん]:               Floating Arith.         27.
* 記号[きごう]:                 Symbolic Atoms.         4.
* 記号アトム[きごうあとむ]:     Symbolic Atoms.         4.
* 正接[せいせつ]:               Floating Arith.         27.
* サブターム[さぶたーむ]:       Display Control.        47.
* 共有メモリ KLIC[きょうゆうめもり KLIC]: Shared-Memory KLIC.  4.
* シグナル[しぐなる]:           Signals.                4.
* シグナルを送る[しぐなるをおくる]: Misc Unix Messages.  4.
* シーク[しーく]:               Common Msgs (C style).  4.
* 新たなリリース[あらたなりりーす]: Reporting Bugs.     4.
* シェル・コマンド[しぇるこまんど]: Misc Unix Messages.  4.
* ジェネリック・メソッド[じぇねりっくめそっど]: Generic Objects.  4.
* ジェネリック・メソッド[じぇねりっくめそっど]: Predicates and Methods.  31.
* ジェネリック・オブジェクト[じぇねりっくおぶじぇくと]: Generic Objects.  4.
* ジェネリック・オブジェクトの生成[じぇねりっくおぶじぇくとのせいせい]: Creating Objects.  4.
* マージング[まーじんぐ]:       Merging.                4.
* 高次[こうじ]:                 Executable Code.        4.
* 構造[こうぞう]:               Structured Data.        4.
* ポストモーテム処理[ぽすともーてむしょり] : System Control.  4.
* ストリーム[すとりーむ]:       Merging.                4.
* スパイ[すぱい]:               Spying.                 4.
* 節[せつ]:                     Predicates.             4.
* メッセージ・ストリーム[めっせーじすとりーむ]: Merging.  4.
* メッセージ送り[めっせーじおくり]: Macros for Paired Arguments.  4.
* メッセージ[めっせーじ]:       Messages.               4.
* メソッド[めそっど]:           Generic Objects.        4.
* メソッド[めそっど]:           Predicates and Methods.  4.
* メイル・リスト[めいるりすと]: Reporting Bugs.         4.
* 双曲線関数[そうきょくせんかんすう]: Floating Arith.   33.
* メイン[めいん]:               Initial Goal.           4.
* モジュール[もじゅーる]:       Modules.                4.
* 実行[じっこう]:               Running.                4.
* タイマ[たいま]:               Timer.                  4.
* 対数[たいすう]:               Floating Arith.         39.
* 実数[じっすう]:               Floating Points.        4.
* 単一化[たんいつか]:           Unification.            4.
* 中止[ちゅうし]:               Predicate Interface.    4.
* 中断ゴール[ちゅうだんごーる]: Dumping Goals.          4.
* 展開対[てんかいつい]:         Paired Arguments.       4.
* 同期[どうき]:                 Common Msgs (C style).  4.
* 読み込み[よみこみ]:           Input Msgs (C style).   4.
* 入力引数[にゅうりょくひきすう]: Argument Modes.       4.
* 入力[にゅうりょく]:           Input and Output.       4.
* 入力[にゅうりょく]:           Input Msgs (C style).   4.
* ボディ・メソッド[ぼでぃめそっど]: Body Methods.       4.
* 配布[はいふ]:                 Copying.                4.
* デクリメント[でくりめんと]:   Macros for Paired Arguments.  4.
* ディレクトリ[でぃれくとり]:   Files & Dirs.           4.
* 配列[はいれつ]:               Vectors.                4.
* デバッグ[でばっぐ]:           Tracing.                4.
* 主ファンクタ[しゅふぁんくた]: Comparison and Hashing.  47.
* 主ファンクタ[しゅふぁんくた]: Functors.               4.
* ポート[ぽーと]:               Port Control.           4.
* アトム[あとむ]:               Symbolic Atoms.         4.
* ポート[ぽーと]:               Trace Ports.            4.
* 否定[ひてい]:                 Predicates.             25.
* 比較[ひかく]:                 Comparison and Hashing.  4.
* アトム・データ[あとむでーた]: Atomic Data.            4.
* トレース[とれーす]:           Tracing.                4.
* トレース表示[とれーすひょうじ]: Display Control.      4.
* トレース表示の深さ制限[とれーすひょうじのふかさせいげん]: Display Control.  29.
* トレース表示の長さ制限[とれーすひょうじのながさせいげん]: Display Control.  34.
* 非同期 I/O[ひどうきI/O]:      Sockets.                39.
* 初期ゴール[しょきごーる]:     Initial Goal.           4.
* 標準入力[ひょうじゅんにゅうりょく]: I/O Opening.      21.
* 標準入力[ひょうじゅんにゅうりょく]: Opening Prolog I/O.  27.
* 標準入出力[ひょうじゅんにゅうしゅつりょく]: I/O Opening.  21.
* 標準順序[ひょうじゅんじゅんじょ]: Comparison and Hashing.  4.
* 標準出力[ひょうじゅんしゅつりょく]: I/O Opening.      21.
* 標準出力[ひょうじゅんしゅつりょく]: Opening Prolog I/O.  27.
* クラス[くらす]:               Predicates and Methods.  31.
* ガード・メソッド[がーどめそっど]: Guard Methods.      4.
* 浮動小数点演算[ふどうしょうすうてんえんざん]: Floating Arith.  4.
* 浮動小数点比較[ふどうしょうすうてんひかく]: Floating Comp.  4.
* 浮動小数点表記[ふどうしょうすうてんひょうき]: Notation of Floats.  4.
* 浮動小数点の演算[ふどうしょうすうてんのえんざん]: Floating Arith.  4.
* 浮動小数点の比較[ふどうしょうすうてんのひかく]: Floating Comp.  4.
* 浮動小数点数[ふどうしょうすうてんすう]: Floating Points.  4.
* 浮動小数点数の生成[ふどうしょうすうてんすうのせいせい]: Creating Floats.  4.
* ラップした項[らっぷしたこう]: Wrapped Terms.          4.
* 分散 KLIC[ぶんさん KLIC]:     Distributed KLIC.       4.
* 文字コード[もじこーど]:       Notation of Integers.   17.
* 文字コード[もじこーど]:       Notation of Integers.   28.
* 文字入力[もじにゅうりょく]:   Input Msgs (C style).   4.
* 文字列[もじれつ]:             Strings.                4.
* 文字列入力[もじれつにゅうりょく]: Input Msgs (C style).  4.
* 文字列の比較[もじれつのひかく]: Predicates on Strings.  4.
* 文字列出力[もじれつしつりょく]: Output Msgs (C style).  4.
* 文字出力[もじしゅつりょく]:   Output Msgs (C style).  4.
* リスト[りすと]:               Lists.                  4.
* リストの表記[りすとのひょうき]: Notation of Lists.    4.
* 並行論理プログラム言語[へいこうろんりぷろぐらむげんご]: Language.  4.
* 並列処理[へいれつしょり]:     Distributed KLIC.       4.
* 並列処理[へいれつしょり]:     Shared-Memory KLIC.     4.
* 平方根[へいほうこん]:         Floating Arith.         42.
* リンケージ[りんけーじ]:       Compiling.              4.
* レコード構造[れこーどこうぞう]: Functors.             4.
* 未束縛[みそくばく]:           Debugging.              4.
* レディー・キュー[れでぃきゅー]: Dumping Goals.        4.
* 余弦[よげん]:                 Floating Arith.         27.
* 優先度[ゆうせんど]:           Execution Status.       4.
* 乱数[らんすう]:               Random Numbers.         4.
* 終了コード[しゅうりょうこーど]: Predicate Interface.  4.
* ハッシング[はっしんんぐ]:     Comparison and Hashing.  4.
* body:                         Basics.                 4.
* バグ報告[ばぐほうこく]:       Reporting Bugs.         4.
* 出力引数[しゅつりょくひきすう]: Argument Modes.       4.
* 出力[しゅつりょく]:           Input and Output.       4.
* 出力のフラッシュ[しゅつりょくのふらっしゅ]: Common Msgs (C style).  4.
* 辞書式順序[じしょしきじゅんじょ]: Predicates on Strings.  4.
* 書き出し[かきだし]:           Output Msgs (C style).  4.
* 述語[じゅつご]:               Predicates.             4.
* 述語[じゅつご]:               Predicates and Methods.  4.
* インストール[いんすとーる]:   Install.                4.
* インライン[いんらいん]:       Inline C Code.          4.
* インクリメント[いんでんと]:   Macros for Paired Arguments.  4.
* アンリンク:                   Files & Dirs.           15.
* インターバルタイマ[いんたーばるたいま]: Timer.        4.
* ダンプ[だんぷ]:               Dumping Goals.          4.
* ファイル[ふぁいる]:           Files & Dirs.           4.
* ファイルの終端[ふぁいるのしゅうたん]: Common Msgs (C style).  4.
* ファイルのクローズ[ふぁいるのくろーず]: Common Msgs (C style).  4.
* ファンクタ[ふぁんくた]:       Functors.               4.
* ファンクタ表記[ふぁんくたひょうき]: Notation of Functors.  4.
* ファンクタの操作[ふぁんくたのそうさ]: Functor Operation.  4.
* フォークプロセス[ふぉーくぷろせす]: Misc Unix Messages.  4.
* オブジェクト生成[おぶじぇくとせいせい]: Creating Objects.  4.
* ブレーク・ポイント[ぶれーくぽいんと]: Spying.         4.
* プログラム[ぷろぐらむ]:       Executable Code.        4.
* プロセス間通信[ぷろせすかんつうしん]: Messages.       4.
* プロセスのフォーク[ぷろせすのふぉーく]: Misc Unix Messages.  4.
* オープン[おーぷん]:           I/O Opening.            30.
* オープン[おーぷん]:           Opening Prolog I/O.     27.
* ヘッダ・ファイル[へっだふぁいる]: Top Insertion.      4.
* 指数[しすう]:                 Floating Arith.         36.
* ガーベージ・コレクション[がーべじこれくしょん]: System Control.  4.
* ベクタ[べくた]:               Vectors.                4.
* 詳細表示[しょうさいひょうじ]: Display Control.        39.
* ベクタの生成[べくたのせいせい]: Creating Vectors.     4.
* 切り上げ[きりあげ]:           Floating Arith.         45.
* 切り捨て[きりすて]:           Floating Arith.         48.
* オペレーティング・システム[おぺれーてぃんぐしすてむ]: Unix.  4.
* C:                            C-like I/O.             4.
* C:                            Inline C Code.          4.
* car:                          Lists.                  4.
* cdr:                          Lists.                  4.
* chdir:                        Files & Dirs.           10.
* clause:                       Basics.                 4.
* clause preference:            Alternatively.          4.
* difference list:              Usage of Paired Arguments.  16.
* execution:                    Basics.                 4.
* GHC:                          Language.               4.
* guard:                        Basics.                 4.
* ICOT 無償公開ソフトウェア[ICOT むしょうこうかいそふとうえあ]: Copying.  4.
* I/O:                          C-like I/O.             4.
* KL1:                          Language.               4.
* Linux:                        Sockets.                51.
* otherwize:                    Predicates.             25.
* preference of clauses:        Alternatively.          4.
* priority:                     Priority.               4.
* PVM:                          Configuration.          4.
* PVM:                          Distributed KLIC.       4.
* Unix インタフェース[Unix いんたふぇーす]: Unix.       4.


